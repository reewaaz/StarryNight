<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>Deep Sky Navigator</title>
    <style>
        :root {
            --primary: #00f3ff;
            --secondary: #ff0055;
            --hud-bg: rgba(8, 12, 20, 0.85);
            --border: 1px solid rgba(0, 243, 255, 0.3);
        }

        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Courier New', Courier, monospace; /* Sci-fi feel */
            color: var(--primary);
            user-select: none;
            -webkit-user-select: none;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }

        /* --- UI LAYERS --- */
        #ui-layer {
            position: absolute;
            z-index: 10;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
        }

        /* Compass Strip */
        .compass-strip-container {
            width: 100%;
            height: 40px;
            background: linear-gradient(to bottom, black, transparent);
            overflow: hidden;
            position: relative;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        .compass-ticks {
            display: flex;
            width: 200%; /* Wide enough to scroll */
            justify-content: space-around;
            position: absolute;
            left: -50%;
            top: 10px;
            color: white;
            font-size: 14px;
            font-weight: bold;
            transition: transform 0.1s linear;
        }
        .center-marker {
            position: absolute;
            left: 50%;
            top: 0;
            bottom: 0;
            width: 2px;
            background: var(--secondary);
            transform: translateX(-50%);
            z-index: 2;
        }

        /* Search Bar */
        .top-hud {
            pointer-events: auto;
            padding: 10px 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .search-box {
            position: relative;
            width: 100%;
            max-width: 400px;
        }

        input {
            width: 100%;
            background: var(--hud-bg);
            border: var(--border);
            color: white;
            padding: 12px 20px;
            border-radius: 4px;
            font-family: inherit;
            text-transform: uppercase;
            outline: none;
            box-sizing: border-box;
            backdrop-filter: blur(5px);
        }

        input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 15px rgba(0, 243, 255, 0.2);
        }

        #search-results {
            position: absolute;
            top: 100%;
            left: 0;
            width: 100%;
            background: black;
            border: var(--border);
            max-height: 200px;
            overflow-y: auto;
            display: none;
        }

        .result-item {
            padding: 10px;
            border-bottom: 1px solid #333;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
        }
        .result-item:hover { background: #111; }
        .type-tag { font-size: 0.8em; color: #888; }

        /* Guidance Arrow (The pointer) */
        #guide-arrow {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            border-left: 20px solid transparent;
            border-right: 20px solid transparent;
            border-bottom: 40px solid var(--secondary);
            transform-origin: center 150px; /* Rotate around center of screen */
            display: none;
            opacity: 0.8;
            filter: drop-shadow(0 0 10px var(--secondary));
        }

        /* Target Lock Reticle */
        #target-reticle {
            position: absolute;
            width: 60px;
            height: 60px;
            border: 2px solid var(--secondary);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            display: none;
            box-shadow: 0 0 15px var(--secondary);
        }
        #target-reticle::after {
            content: attr(data-label);
            position: absolute;
            top: 110%;
            left: 50%;
            transform: translateX(-50%);
            white-space: nowrap;
            background: black;
            padding: 2px 5px;
            font-size: 12px;
        }

        /* Footer HUD */
        .bottom-hud {
            margin-top: auto;
            padding: 20px;
            background: linear-gradient(to top, black, transparent);
            text-align: center;
        }
        #info-display h1 { margin: 0; font-size: 24px; letter-spacing: 2px; }
        #info-display p { margin: 5px 0 0 0; font-size: 12px; color: #aaa; }

        /* Splash Screen */
        #splash {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: #050505;
            z-index: 100;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            pointer-events: auto;
        }
        button.btn-start {
            margin-top: 20px;
            padding: 15px 40px;
            background: transparent;
            border: 2px solid var(--primary);
            color: var(--primary);
            font-size: 18px;
            font-family: inherit;
            cursor: pointer;
            box-shadow: 0 0 20px rgba(0,243,255,0.2);
            transition: 0.3s;
        }
        button.btn-start:hover {
            background: var(--primary);
            color: black;
        }

    </style>
</head>
<body>

    <!-- Splash Screen -->
    <div id="splash">
        <h1 style="font-size: 3rem; text-shadow: 0 0 20px var(--primary);">SKY<span style="color:white">NET</span></h1>
        <p>Calibrating sensors...</p>
        <button class="btn-start" onclick="startApp()">INITIALIZE SYSTEM</button>
        <p style="font-size: 10px; color: #555; margin-top: 30px;">Requires Gyroscope & HTTPS</p>
    </div>

    <!-- UI Overlay -->
    <div id="ui-layer">
        
        <!-- Compass -->
        <div class="compass-strip-container">
            <div class="center-marker"></div>
            <div class="compass-ticks" id="compass-ticks">
                <span>N</span><span>NE</span><span>E</span><span>SE</span><span>S</span><span>SW</span><span>W</span><span>NW</span><span>N</span>
            </div>
        </div>

        <!-- Search -->
        <div class="top-hud">
            <div class="search-box">
                <input type="text" id="search-input" placeholder="SEARCH DATABASE..." autocomplete="off">
                <div id="search-results"></div>
            </div>
        </div>

        <!-- 3D Overlays -->
        <div id="guide-arrow"></div>
        <div id="target-reticle" data-label=""></div>

        <!-- Footer -->
        <div class="bottom-hud">
            <div id="info-display">
                <h1 id="hud-title">SYSTEM READY</h1>
                <p id="hud-sub">Scanning Sector...</p>
            </div>
        </div>
    </div>

    <!-- 3D Container -->
    <div id="canvas-container"></div>

    <!-- Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        // ==========================================
        // 1. CELESTIAL DATABASE
        // ==========================================
        
        // Helper to convert RA (Hours/Min) and Dec (Deg/Min) to Decimal Degrees
        const toDeg = (h, m, s=0) => (h + m/60 + s/3600) * 15; // RA to degrees
        const decToDeg = (d, m, s=0) => (d < 0 ? d - m/60 - s/3600 : d + m/60 + s/3600);

        // Star Colors based on spectral type
        const COLORS = {
            O: 0x9db4ff, B: 0xaabfff, A: 0xcad8ff, F: 0xfbf8ff, 
            G: 0xfff4e8, K: 0xffddb4, M: 0xffbd6f, 
            DeepSky: 0x00ffcc, Planet: 0xffaa88, Moon: 0xcccccc
        };

        const DB = [
            // Solar System (Approximate Static Positions for Demo)
            { name: "Sun", type: "Star", ra: 0, dec: 0, dist: 1, size: 10, color: 0xffff00 },
            { name: "Mercury", type: "Planet", ra: 20, dec: 10, dist: 1, size: 3, color: 0xaaaaaa },
            { name: "Venus", type: "Planet", ra: 40, dec: 15, dist: 1, size: 5, color: 0xeebb99 },
            { name: "Mars", type: "Planet", ra: 300, dec: -20, dist: 1, size: 4, color: 0xff3300 },
            { name: "Jupiter", type: "Planet", ra: 120, dec: 20, dist: 1, size: 8, color: 0xffdca1 },
            { name: "Saturn", type: "Planet", ra: 200, dec: -10, dist: 1, size: 7, color: 0xf4d03f },
            { name: "Moon", type: "Moon", ra: 15, dec: 5, dist: 1, size: 4, color: 0xeeeeee },
            { name: "ISS", type: "Satellite", ra: 180, dec: 45, dist: 0.9, size: 2, color: 0x00ff00 }, // Mock position

            // Bright Stars
            { name: "Sirius", type: "Star", ra: toDeg(6,45), dec: decToDeg(-16,42), size: 3, color: COLORS.A },
            { name: "Canopus", type: "Star", ra: toDeg(6,23), dec: decToDeg(-52,41), size: 2.8, color: COLORS.F },
            { name: "Arcturus", type: "Star", ra: toDeg(14,15), dec: decToDeg(19,10), size: 2.8, color: COLORS.K },
            { name: "Alpha Centauri", type: "Star", ra: toDeg(14,39), dec: decToDeg(-60,50), size: 2.8, color: COLORS.G },
            { name: "Vega", type: "Star", ra: toDeg(18,36), dec: decToDeg(38,47), size: 2.8, color: COLORS.A },
            { name: "Rigel", type: "Star", ra: toDeg(5,14), dec: decToDeg(-8,12), size: 2.8, color: COLORS.B },
            { name: "Procyon", type: "Star", ra: toDeg(7,39), dec: decToDeg(5,13), size: 2.6, color: COLORS.F },
            { name: "Betelgeuse", type: "Star", ra: toDeg(5,55), dec: decToDeg(7,24), size: 3, color: COLORS.M },
            { name: "Altair", type: "Star", ra: toDeg(19,50), dec: decToDeg(8,52), size: 2.5, color: COLORS.A },
            { name: "Aldebaran", type: "Star", ra: toDeg(4,35), dec: decToDeg(16,30), size: 2.6, color: COLORS.K },
            { name: "Antares", type: "Star", ra: toDeg(16,29), dec: decToDeg(-26,25), size: 2.7, color: COLORS.M },
            { name: "Pollux", type: "Star", ra: toDeg(7,45), dec: decToDeg(28,1), size: 2.4, color: COLORS.K },
            { name: "Deneb", type: "Star", ra: toDeg(20,41), dec: decToDeg(45,16), size: 2.4, color: COLORS.A },
            { name: "Polaris", type: "Star", ra: toDeg(2,31), dec: decToDeg(89,15), size: 2.4, color: COLORS.F },
            
            // Deep Sky Objects
            { name: "Andromeda Galaxy (M31)", type: "Galaxy", ra: toDeg(0,42), dec: decToDeg(41,16), size: 6, color: 0xccaaff },
            { name: "Orion Nebula (M42)", type: "Nebula", ra: toDeg(5,35), dec: decToDeg(-5,23), size: 5, color: 0xff00aa },
            { name: "Pleiades (M45)", type: "Cluster", ra: toDeg(3,47), dec: decToDeg(24,7), size: 5, color: 0x88ccff },
            { name: "Galactic Center (Sgr A*)", type: "Black Hole", ra: toDeg(17,45), dec: decToDeg(-29,0), size: 8, color: 0xaa00aa }
        ];

        // Add 500 Random "Named" stars just for density in search
        for(let i=0; i<50; i++) {
            DB.push({
                name: `HIP ${Math.floor(Math.random()*100000)}`,
                type: "Star",
                ra: Math.random()*360,
                dec: (Math.random()*180)-90,
                size: 1.5,
                color: COLORS.G
            });
        }

        // ==========================================
        // 2. APP STATE
        // ==========================================
        
        let scene, camera, renderer;
        let starField, milkyWay;
        let targetObject = null; // The object we are guiding to
        let objectMeshes = [];
        
        // Sensor variables
        let isSensorActive = false;

        // ==========================================
        // 3. INITIALIZATION
        // ==========================================

        function startApp() {
            if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
                DeviceOrientationEvent.requestPermission()
                    .then(response => {
                        if (response === 'granted') {
                            isSensorActive = true;
                            init3D();
                        } else {
                            alert("Permission denied. The app needs sensors to work.");
                        }
                    })
                    .catch(console.error);
            } else {
                isSensorActive = true;
                init3D();
            }
        }

        function init3D() {
            document.getElementById('splash').style.display = 'none';

            // Scene Setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000005);
            scene.fog = new THREE.FogExp2(0x000005, 0.001);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 2000);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // 1. Create Environment
            createStarField();
            createMilkyWay();
            createCardinalMarkers();
            
            // 2. Create Database Objects
            populateUniverse();

            // 3. Events
            window.addEventListener('resize', onResize);
            if(isSensorActive) {
                window.addEventListener('deviceorientation', onDeviceOrientation);
            } else {
                // Fallback for desktop testing (Orbit controls simulation logic here if needed)
                alert("Sensors not active. Desktop debug mode.");
            }

            // Start Loop
            animate();
        }

        // ==========================================
        // 4. SCENE GENERATION
        // ==========================================

        function createStarField() {
            const geometry = new THREE.BufferGeometry();
            const count = 3000;
            const positions = [];
            const colors = [];
            const color = new THREE.Color();

            for(let i=0; i<count; i++) {
                // Random point on sphere
                const r = 1000;
                const theta = 2 * Math.PI * Math.random();
                const phi = Math.acos(2 * Math.random() - 1);
                const x = r * Math.sin(phi) * Math.cos(theta);
                const y = r * Math.sin(phi) * Math.sin(theta);
                const z = r * Math.cos(phi);
                positions.push(x,y,z);

                // Random color tint
                const starType = Math.random();
                if(starType > 0.9) color.setHex(COLORS.O);
                else if(starType > 0.6) color.setHex(COLORS.A);
                else if(starType > 0.3) color.setHex(COLORS.G);
                else color.setHex(COLORS.M);
                
                colors.push(color.r, color.g, color.b);
            }

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

            const material = new THREE.PointsMaterial({
                size: 2,
                vertexColors: true,
                transparent: true,
                opacity: 0.8,
                sizeAttenuation: false // Keep stars small
            });

            starField = new THREE.Points(geometry, material);
            scene.add(starField);
        }

        function createMilkyWay() {
            // A dense band of particles
            const geometry = new THREE.BufferGeometry();
            const count = 10000;
            const positions = [];
            const colors = [];
            const c1 = new THREE.Color(0x4400ff); // Deep purple
            const c2 = new THREE.Color(0x00ccff); // Cyan

            for(let i=0; i<count; i++) {
                // Ring distribution
                const r = 900;
                const angle = Math.random() * Math.PI * 2;
                // Spread width of galaxy band
                const spread = (Math.random() - 0.5) * 300; 
                
                // Base circle on XZ plane, then rotate to align with sky
                const x = r * Math.cos(angle);
                const y = spread; 
                const z = r * Math.sin(angle);

                // Rotate 60 degrees to mimic galactic plane tilt relative to Earth
                const vec = new THREE.Vector3(x, y, z);
                vec.applyAxisAngle(new THREE.Vector3(1,0,0), Math.PI/3); 

                positions.push(vec.x, vec.y, vec.z);

                const mixedColor = c1.clone().lerp(c2, Math.random());
                colors.push(mixedColor.r, mixedColor.g, mixedColor.b);
            }

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

            const material = new THREE.PointsMaterial({
                size: 3,
                vertexColors: true,
                transparent: true,
                opacity: 0.3,
                blending: THREE.AdditiveBlending
            });

            milkyWay = new THREE.Points(geometry, material);
            scene.add(milkyWay);
        }

        function populateUniverse() {
            DB.forEach(obj => {
                // Math: RA (0-360) -> Theta, Dec (-90 to 90) -> Phi
                // Coordinate conversion to Cartesian
                const r = 500; // Unified distance for projection, though conceptually different
                const theta = THREE.MathUtils.degToRad(obj.ra);
                const phi = THREE.MathUtils.degToRad(90 - obj.dec);

                // X is West, Z is North (roughly in this mapping for skybox)
                // Y is Up in Three.js
                // We map: Y axis = Celestial North Pole
                const x = r * Math.sin(phi) * Math.cos(theta);
                const y = r * Math.cos(phi);
                const z = r * Math.sin(phi) * Math.sin(theta);

                // Visual Representation
                let geometry, material;
                
                if (obj.type === "Planet") {
                     geometry = new THREE.SphereGeometry(obj.size, 16, 16);
                     material = new THREE.MeshBasicMaterial({ color: obj.color });
                } else if(obj.type === "Galaxy" || obj.type === "Nebula") {
                    geometry = new THREE.CircleGeometry(obj.size * 2, 8);
                    material = new THREE.MeshBasicMaterial({ color: obj.color, side: THREE.DoubleSide, transparent:true, opacity: 0.6 });
                    geometry.lookAt(new THREE.Vector3(0,0,0)); // Face center
                } else {
                    // Stars
                    geometry = new THREE.SphereGeometry(obj.size, 8, 8);
                    material = new THREE.MeshBasicMaterial({ color: obj.color });
                }

                const mesh = new THREE.Mesh(geometry, material);
                mesh.position.set(x, y, z);
                mesh.userData = obj; // Attach Data

                // Add Label Sprite (only visible when close or searched? For now, no labels to keep clean)
                
                scene.add(mesh);
                objectMeshes.push(mesh);
            });
        }

        function createCardinalMarkers() {
            const distance = 600;
            const dirs = [
                { text: "N", x: 0, y: 0, z: -distance, color: "#ff0055" },
                { text: "S", x: 0, y: 0, z: distance, color: "white" },
                { text: "E", x: distance, y: 0, z: 0, color: "white" },
                { text: "W", x: -distance, y: 0, z: 0, color: "white" }
            ];

            const loader = new THREE.TextureLoader();

            dirs.forEach(d => {
                const canvas = document.createElement('canvas');
                canvas.width = 128; canvas.height = 128;
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = d.color;
                ctx.font = "bold 80px Arial";
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.fillText(d.text, 64, 64);
                
                const texture = new THREE.CanvasTexture(canvas);
                const spriteMat = new THREE.SpriteMaterial({ map: texture });
                const sprite = new THREE.Sprite(spriteMat);
                sprite.position.set(d.x, d.y, d.z);
                sprite.scale.set(40, 40, 1);
                scene.add(sprite);
            });
            
            // Horizon Grid
            const grid = new THREE.PolarGridHelper(600, 16, 8, 64, 0x004444, 0x001111);
            scene.add(grid);
        }

        // ==========================================
        // 5. NAVIGATION & LOGIC
        // ==========================================

        function onDeviceOrientation(event) {
            const alpha = event.alpha ? THREE.MathUtils.degToRad(event.alpha) : 0; // Z
            const beta = event.beta ? THREE.MathUtils.degToRad(event.beta) : 0;    // X
            const gamma = event.gamma ? THREE.MathUtils.degToRad(event.gamma) : 0; // Y
            const orient = window.orientation ? THREE.MathUtils.degToRad(window.orientation) : 0;

            const euler = new THREE.Euler(beta, alpha, -gamma, 'YXZ');
            const q1 = new THREE.Quaternion(-Math.sqrt(0.5), 0, 0, Math.sqrt(0.5)); // - PI/2 around X
            
            const quaternion = new THREE.Quaternion();
            quaternion.setFromEuler(euler);
            quaternion.multiply(q1);
            
            // Apply orientation compensation
            const qOrient = new THREE.Quaternion();
            qOrient.setFromAxisAngle(new THREE.Vector3(0,0,1), -orient);
            quaternion.multiply(qOrient);

            camera.quaternion.copy(quaternion);

            // Update Compass UI
            // Alpha is roughly 0-360. 
            // We shift the compass strip background position
            const deg = event.alpha; 
            const pixelShift = (deg / 360) * 50; // 50% width
            document.getElementById('compass-ticks').style.transform = `translateX(-${pixelShift}%)`;
        }

        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // ==========================================
        // 6. SEARCH & GUIDANCE SYSTEM
        // ==========================================

        const searchInput = document.getElementById('search-input');
        const resultsDiv = document.getElementById('search-results');
        const guideArrow = document.getElementById('guide-arrow');
        const targetReticle = document.getElementById('target-reticle');
        const infoTitle = document.getElementById('hud-title');
        const infoSub = document.getElementById('hud-sub');

        searchInput.addEventListener('input', (e) => {
            const val = e.target.value.toLowerCase();
            resultsDiv.innerHTML = "";
            if(val.length < 1) { resultsDiv.style.display = 'none'; return; }

            const matches = DB.filter(obj => obj.name.toLowerCase().includes(val));
            
            if(matches.length > 0) {
                resultsDiv.style.display = 'block';
                matches.forEach(obj => {
                    const el = document.createElement('div');
                    el.className = 'result-item';
                    el.innerHTML = `<span>${obj.name}</span><span class="type-tag">${obj.type}</span>`;
                    el.onclick = () => selectTarget(obj);
                    resultsDiv.appendChild(el);
                });
            } else {
                resultsDiv.style.display = 'none';
            }
        });

        function selectTarget(obj) {
            targetObject = obj;
            resultsDiv.style.display = 'none';
            searchInput.value = obj.name;
            infoTitle.innerText = "TRACKING: " + obj.name.toUpperCase();
            infoSub.innerText = `Type: ${obj.type} | RA: ${obj.ra.toFixed(2)} | Dec: ${obj.dec.toFixed(2)}`;
            
            // Find the 3D mesh
            const mesh = objectMeshes.find(m => m.userData === obj);
            if(mesh) {
                targetObject.position = mesh.position;
            }
        }

        function updateGuidance() {
            if(!targetObject) return;

            // Project target position to screen
            const vector = targetObject.position.clone();
            vector.project(camera);

            const screenX = (vector.x * .5 + .5) * window.innerWidth;
            const screenY = (-(vector.y * .5) + .5) * window.innerHeight;

            // Check if object is behind camera
            const isBehind = vector.z > 1; // z > 1 in NDC means behind near plane usually, but check standard NDC

            // Logic:
            // If visible (x,y in 0-1 range and !isBehind) -> Show Reticle
            // If not visible -> Show Arrow pointing to it

            const margin = 50;
            const inView = !isBehind && vector.x >= -0.9 && vector.x <= 0.9 && vector.y >= -0.9 && vector.y <= 0.9;

            if (inView) {
                // LOCK ON
                guideArrow.style.display = 'none';
                targetReticle.style.display = 'block';
                targetReticle.style.left = screenX + 'px';
                targetReticle.style.top = screenY + 'px';
                targetReticle.setAttribute('data-label', targetObject.name);
                targetReticle.style.borderColor = "#00ff00"; // Green for lock
            } else {
                // GUIDE
                targetReticle.style.display = 'none';
                guideArrow.style.display = 'block';

                // Calculate angle to center
                const cx = window.innerWidth / 2;
                const cy = window.innerHeight / 2;
                
                // If behind, invert position
                let tx = screenX; 
                let ty = screenY;
                
                // Angle calculation
                let angle = Math.atan2(ty - cy, tx - cx) * (180 / Math.PI);
                
                // If behind the camera, the math flips, we need to correct direction
                // Actually, if z > 1, the projection math is inverted.
                // Simple hack: Look at the vector relative to camera quaternion
                
                // Let's use a simpler 3D arrow logic:
                // Get local position of target relative to camera
                const localPos = targetObject.position.clone().applyMatrix4(camera.matrixWorldInverse);
                
                // Angle in the XY plane of the camera
                const angleRad = Math.atan2(localPos.y, localPos.x);
                // Convert to degrees and rotate CSS arrow
                // CSS rotation 0 is pointing Up? 
                // Our arrow points Down. 
                // We rotate the div which is centered.
                
                const cssAngle = (angleRad * 180 / Math.PI) - 90; // Adjust based on CSS arrow orientation

                guideArrow.style.transform = `translate(-50%, -50%) rotate(${cssAngle}deg) translateY(120px)`; 
                // translateY pushes it to the edge of the orbit
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            updateGuidance();
            renderer.render(scene, camera);
        }

    </script>
</body>
</html>
