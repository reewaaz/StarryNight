<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>StellarNav - AR Sky Viewer</title>
    <script src="https://cdn.jsdelivr.net/npm/astronomy-engine@2.1.19/astronomy.browser.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif; color: white; }
        canvas { display: block; width: 100vw; height: 100vh; }
        
        /* UI Overlay - Glassmorphism */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            display: flex; flex-direction: column; justify-content: space-between;
        }

        .glass-panel {
            background: rgba(20, 30, 50, 0.6);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 12px;
            pointer-events: auto;
            margin: 10px;
        }

        /* Header / Search */
        #top-bar {
            display: flex; gap: 10px; align-items: center;
        }
        
        input#search-box {
            background: rgba(0,0,0,0.3); border: 1px solid rgba(255,255,255,0.2);
            color: white; padding: 8px 12px; border-radius: 20px; flex-grow: 1;
            font-size: 16px; outline: none;
        }
        input#search-box::placeholder { color: rgba(255,255,255,0.5); }

        /* Reticle */
        #reticle {
            position: absolute; top: 50%; left: 50%;
            width: 40px; height: 40px;
            transform: translate(-50%, -50%);
            border: 2px solid rgba(0, 255, 255, 0.5);
            border-radius: 50%;
            pointer-events: none;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.3);
        }
        #reticle::after {
            content: ''; position: absolute; top: 50%; left: 50%;
            width: 4px; height: 4px; background: cyan;
            transform: translate(-50%, -50%); border-radius: 50%;
        }

        /* Info Panel */
        #info-panel {
            min-height: 80px;
            transition: opacity 0.3s;
            opacity: 0.8;
        }
        #object-name { font-size: 1.2rem; font-weight: bold; color: #4db8ff; margin: 0; }
        #object-coords { font-size: 0.8rem; color: #aaa; margin-top: 4px; font-family: monospace; }
        #guidance-msg { color: #ffeb3b; font-size: 0.9rem; margin-top: 5px; font-style: italic; display: none; }

        /* Start Overlay */
        #start-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; z-index: 1000;
            display: flex; flex-direction: column;
            align-items: center; justify-content: center;
            text-align: center;
        }
        button.primary-btn {
            background: linear-gradient(135deg, #00c6ff, #0072ff);
            border: none; color: white; padding: 15px 40px;
            font-size: 18px; border-radius: 30px;
            margin-top: 20px; cursor: pointer;
            box-shadow: 0 0 20px rgba(0, 114, 255, 0.5);
            pointer-events: auto;
        }

        /* Zoom Info */
        #zoom-level {
            position: absolute; right: 20px; top: 50%; 
            transform: translateY(-50%);
            writing-mode: vertical-rl; text-orientation: mixed;
            font-size: 10px; color: rgba(255,255,255,0.4);
        }
    </style>
    
    <!-- Import Maps for Three.js -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <div id="start-overlay">
        <h1 style="margin-bottom: 10px;">StellarNav</h1>
        <p style="color: #888; max-width: 80%;">Point your phone at the sky.<br>Requires GPS and Sensor access.</p>
        <button id="start-btn" class="primary-btn">Start Exploring</button>
    </div>

    <div id="ui-layer">
        <div id="top-bar" class="glass-panel">
            <input type="text" id="search-box" placeholder="Search (e.g., Mars, Sun)..." autocomplete="off">
        </div>
        
        <div id="reticle"></div>
        <div id="zoom-level">FOV: 75째</div>

        <div id="info-panel" class="glass-panel">
            <h2 id="object-name">Scanning...</h2>
            <div id="object-coords">--</div>
            <div id="guidance-msg"></div>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { DeviceOrientationControls } from 'three/addons/controls/DeviceOrientationControls.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- Configuration ---
        const RENDER_DISTANCE = 2000;
        const EARTH_RADIUS_GL = 10; 
        
        // --- State ---
        let scene, camera, renderer, controls;
        let deviceControls = null;
        let orbitControls = null;
        let celestialObjects = []; // Stores planets/sun/moon meshes
        let starField;
        let constellations = [];
        let raycaster, centerVector;
        let selectedObject = null;
        let userLocation = { lat: 0, lon: 0, el: 0 }; // Default
        let isSensorsActive = false;
        
        // --- Elements ---
        const infoName = document.getElementById('object-name');
        const infoCoords = document.getElementById('object-coords');
        const guideMsg = document.getElementById('guidance-msg');
        const searchInput = document.getElementById('search-box');
        const startBtn = document.getElementById('start-btn');
        const startOverlay = document.getElementById('start-overlay');
        const zoomLabel = document.getElementById('zoom-level');

        // --- Initialization ---
        function init() {
            // Scene Setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x020205);
            // Fog to soften the horizon
            scene.fog = new THREE.FogExp2(0x020205, 0.0002);

            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, RENDER_DISTANCE * 2);
            camera.position.set(0, 0, 0.1); // Slightly up

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);

            // Raycaster
            raycaster = new THREE.Raycaster();
            centerVector = new THREE.Vector2(0, 0);

            // Light
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);

            // Helper Grid (Horizon)
            const gridHelper = new THREE.PolarGridHelper(RENDER_DISTANCE, 16, 8, 64, 0x333333, 0x111111);
            gridHelper.position.y = -2;
            scene.add(gridHelper);

            // Initial Object Generation
            createStarField();
            createGuideArrow();

            // Event Listeners
            window.addEventListener('resize', onWindowResize);
            addPinchToZoom();

            // Start Animation Loop
            animate();
        }

        // --- Core Logic: Celestial Positioning ---

        function updateCelestialBodies() {
            if (!userLocation.lat && !userLocation.lon) return;

            const date = new Date();
            const observer = new Astronomy.Observer(userLocation.lat, userLocation.lon, userLocation.el);

            // Clear old dynamic objects (planets/sun/moon) if any to update positions
            // Optimization: In a full app, we would update positions, not recreate meshes.
            // For this single file, we update coordinates.

            const bodies = [
                { name: 'Sun', body: Astronomy.Body.Sun, color: 0xFFD700, scale: 15 },
                { name: 'Moon', body: Astronomy.Body.Moon, color: 0xCCCCCC, scale: 12 },
                { name: 'Mercury', body: Astronomy.Body.Mercury, color: 0xA5A5A5, scale: 3 },
                { name: 'Venus', body: Astronomy.Body.Venus, color: 0xE3BB76, scale: 5 },
                { name: 'Mars', body: Astronomy.Body.Mars, color: 0xFF4500, scale: 4 },
                { name: 'Jupiter', body: Astronomy.Body.Jupiter, color: 0xD9A066, scale: 10 },
                { name: 'Saturn', body: Astronomy.Body.Saturn, color: 0xF4D03F, scale: 9 },
                { name: 'Uranus', body: Astronomy.Body.Uranus, color: 0x4FD0E7, scale: 6 },
                { name: 'Neptune', body: Astronomy.Body.Neptune, color: 0x4169E1, scale: 6 }
            ];

            bodies.forEach(data => {
                const equ_2000 = Astronomy.Equator(data.body, date, observer, false, true);
                const hor = Astronomy.Horizon(date, observer, equ_2000.ra, equ_2000.dec, 'normal');
                
                let mesh = celestialObjects.find(o => o.userData.name === data.name);

                if (!mesh) {
                    // Create mesh if not exists
                    const geometry = new THREE.SphereGeometry(data.scale, 16, 16);
                    // Simple glow material
                    const material = new THREE.MeshBasicMaterial({ color: data.color });
                    mesh = new THREE.Mesh(geometry, material);
                    mesh.userData = { name: data.name, type: 'planet' };
                    
                    // Add Label Sprite
                    const label = createTextSprite(data.name);
                    label.position.set(0, data.scale + 2, 0);
                    mesh.add(label);

                    scene.add(mesh);
                    celestialObjects.push(mesh);
                }

                // Convert Horizontal (Az/Alt) to Cartesian
                // Three.js: Y is up. Z is South (usually), X is East.
                // Azimuth: 0 is North, 90 East, 180 South, 270 West.
                // Altitude: 0 Horizon, 90 Zenith.
                
                const r = 800; // Distance to place objects
                const phi = (90 - hor.altitude) * (Math.PI / 180); 
                const theta = -hor.azimuth * (Math.PI / 180); // Negative to match coord sys

                // Convert Spherical to Cartesian (Y-up)
                // Note: We need to align this with DeviceOrientationControls which assumes North is Z-
                // Actually, DOC uses standard mapping. We usually need a compass offset.
                // Standard: X=East, Z=South, Y=Up.
                // Azimuth formula: x = r * sin(theta) * sin(phi), y = r * cos(phi), z = r * cos(theta) * sin(phi)
                
                // Adjusting for ThreeJS default orientation
                const x = r * Math.sin(theta) * Math.sin(phi);
                const y = r * Math.cos(phi);
                const z = r * Math.cos(theta) * Math.sin(phi);

                mesh.position.set(x, y, z);
                mesh.lookAt(0,0,0);
            });
        }

        function createStarField() {
            // A simple random star field for visual fill
            const geometry = new THREE.BufferGeometry();
            const count = 2000;
            const positions = new Float32Array(count * 3);
            const colors = new Float32Array(count * 3);

            for(let i = 0; i < count; i++) {
                // Random spherical coordinates
                const r = 1500;
                const theta = 2 * Math.PI * Math.random();
                const phi = Math.acos(2 * Math.random() - 1);

                const x = r * Math.sin(phi) * Math.cos(theta);
                const y = r * Math.sin(phi) * Math.sin(theta);
                const z = r * Math.cos(phi);

                positions[i*3] = x;
                positions[i*3+1] = y;
                positions[i*3+2] = z;

                // Color variation (Blueish to Reddish)
                const starType = Math.random();
                let c = new THREE.Color();
                if(starType > 0.9) c.setHex(0xaaaaaa); // white
                else if(starType > 0.7) c.setHex(0xffddaa); // yellow
                else if(starType > 0.5) c.setHex(0xaaddff); // blue
                else c.setHex(0xffffff); 

                colors[i*3] = c.r;
                colors[i*3+1] = c.g;
                colors[i*3+2] = c.b;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            const material = new THREE.PointsMaterial({
                size: 4,
                vertexColors: true,
                sizeAttenuation: false,
                transparent: true,
                opacity: 0.8
            });

            starField = new THREE.Points(geometry, material);
            scene.add(starField);
        }

        // --- Visual Helpers ---

        function createTextSprite(message) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 256; 
            canvas.height = 128;
            
            ctx.fillStyle = "rgba(0,0,0,0)";
            ctx.fillRect(0,0,256,128);
            ctx.font = "Bold 40px Arial";
            ctx.fillStyle = "white";
            ctx.textAlign = "center";
            ctx.fillText(message, 128, 64);

            const texture = new THREE.CanvasTexture(canvas);
            const spriteMaterial = new THREE.SpriteMaterial({ map: texture, transparent: true });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.scale.set(20, 10, 1);
            return sprite;
        }

        let guideArrow;
        function createGuideArrow() {
            const geometry = new THREE.ConeGeometry(2, 10, 8);
            geometry.rotateX(Math.PI / 2); // Point Z
            const material = new THREE.MeshBasicMaterial({ color: 0xffeb3b, wireframe: false, transparent: true, opacity: 0.6 });
            guideArrow = new THREE.Mesh(geometry, material);
            guideArrow.position.set(0, 0, -20); // In front of camera
            guideArrow.visible = false;
            // We don't add to scene, we add to camera so it's HUD-like but in 3D
            camera.add(guideArrow);
            scene.add(camera);
        }

        // --- Interaction ---

        function updateRaycaster() {
            raycaster.setFromCamera(centerVector, camera);
            const intersects = raycaster.intersectObjects(celestialObjects);

            if (intersects.length > 0) {
                const obj = intersects[0].object;
                infoName.innerText = obj.userData.name;
                // Calculate Alt/Az for display
                const p = obj.position.clone().normalize();
                const alt = 90 - (Math.acos(p.y) * 180 / Math.PI);
                const az = (Math.atan2(p.x, p.z) * 180 / Math.PI);
                infoCoords.innerText = `Az: ${Math.round(az < 0 ? az + 360 : az)}째 Alt: ${Math.round(alt)}째`;
            } else {
                infoName.innerText = "Sky View";
                infoCoords.innerText = "Scanning...";
            }
        }

        // --- GPS & Sensors ---

        function startExperience() {
            // 1. Get Location
            if (navigator.geolocation) {
                navigator.geolocation.getCurrentPosition((pos) => {
                    userLocation.lat = pos.coords.latitude;
                    userLocation.lon = pos.coords.longitude;
                    updateCelestialBodies();
                    infoCoords.innerText = "GPS Locked. Calibrating Sensors...";
                }, (err) => {
                    alert("GPS denied. Using default location (Null Island).");
                    userLocation = { lat: 0, lon: 0 };
                    updateCelestialBodies();
                });
            }

            // 2. Request Sensor Permission (iOS 13+)
            if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
                DeviceOrientationEvent.requestPermission()
                    .then(response => {
                        if (response === 'granted') {
                            activateSensors();
                        } else {
                            alert("Permission denied. Using touch controls.");
                            activateTouchControls();
                        }
                    })
                    .catch(console.error);
            } else {
                // Non-iOS 13+ devices
                activateSensors();
            }

            // Hide overlay
            startOverlay.style.display = 'none';
        }

        function activateSensors() {
            // If device supports orientation
            deviceControls = new DeviceOrientationControls(camera);
            deviceControls.alphaOffset = 0; // Compass correction can be applied here
            isSensorsActive = true;
        }

        function activateTouchControls() {
            orbitControls = new OrbitControls(camera, renderer.domElement);
            orbitControls.enablePan = false;
            orbitControls.enableZoom = false;
            orbitControls.rotateSpeed = 0.5;
            isSensorsActive = false;
        }

        // --- Pinch to Zoom ---
        function addPinchToZoom() {
            let initialDistance = 0;
            let initialFov = 75;

            document.addEventListener('touchstart', (e) => {
                if (e.touches.length === 2) {
                    const dx = e.touches[0].pageX - e.touches[1].pageX;
                    const dy = e.touches[0].pageY - e.touches[1].pageY;
                    initialDistance = Math.sqrt(dx * dx + dy * dy);
                    initialFov = camera.fov;
                }
            }, {passive: false});

            document.addEventListener('touchmove', (e) => {
                if (e.touches.length === 2) {
                    const dx = e.touches[0].pageX - e.touches[1].pageX;
                    const dy = e.touches[0].pageY - e.touches[1].pageY;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    const ratio = initialDistance / distance;
                    let newFov = initialFov * ratio;
                    
                    // Clamp FOV
                    newFov = Math.max(10, Math.min(100, newFov));
                    camera.fov = newFov;
                    camera.updateProjectionMatrix();
                    zoomLabel.innerText = `FOV: ${Math.round(newFov)}째`;
                    e.preventDefault(); // Prevent browser zoom
                }
            }, {passive: false});
        }

        // --- Search Logic ---
        searchInput.addEventListener('change', (e) => {
            const query = e.target.value.toLowerCase();
            const target = celestialObjects.find(obj => obj.userData.name.toLowerCase() === query);
            
            if(target) {
                selectedObject = target;
                guideMsg.style.display = 'block';
                guideMsg.innerText = `Turn to find ${target.userData.name}`;
                guideArrow.visible = true;
            } else {
                selectedObject = null;
                guideMsg.style.display = 'none';
                guideArrow.visible = false;
            }
        });

        function updateGuideArrow() {
            if (!selectedObject) return;
            
            // Calculate direction to target in World space
            const targetPos = selectedObject.position.clone();
            
            // Look at target relative to camera is tricky in HUD
            // Easier: Place arrow in world space, but close to camera? 
            // Better strategy for "Compass Arrow" on HUD:
            // Project target vector onto screen space?
            
            // Simple approach: The arrow is a child of the camera.
            // We want the arrow to point toward the world position of the object.
            
            // 1. Get target world position
            // 2. Convert to camera local space
            camera.updateMatrixWorld();
            const localPos = targetPos.clone().applyMatrix4(camera.matrixWorldInverse);
            
            // Point arrow at local pos
            guideArrow.lookAt(localPos);
            
            // Check if visible in frustum
            const frustum = new THREE.Frustum();
            frustum.setFromProjectionMatrix(new THREE.Matrix4().multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse));
            if (frustum.containsPoint(targetPos)) {
                guideMsg.innerText = "Target in view!";
                guideArrow.material.color.setHex(0x00ff00);
            } else {
                guideMsg.innerText = `Find ${selectedObject.userData.name} ->`;
                guideArrow.material.color.setHex(0xffeb3b);
            }
        }

        // --- Main Loop ---
        function animate() {
            requestAnimationFrame(animate);

            if (isSensorsActive && deviceControls) {
                deviceControls.update();
            } else if (orbitControls) {
                orbitControls.update();
            }

            // Update real-time position every second? 
            // For now, doing it per frame is overkill for planets, but fine for smooth UI
            // We will just do raycasting per frame
            updateRaycaster();
            if(selectedObject) updateGuideArrow();

            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // Initialize Start Button
        startBtn.addEventListener('click', startExperience);
        
        // Run Setup
        init();

    </script>
</body>
</html>
