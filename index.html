<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>Orion: Real-Time Sky Tracker</title>
    <style>
        :root {
            --hud-color: #00f3ff;
            --alert-color: #ff0055;
            --bg-glass: rgba(10, 15, 20, 0.85);
        }

        body { margin: 0; overflow: hidden; background: #000; font-family: 'Rajdhani', sans-serif; color: white; }
        
        #canvas-container { position: absolute; top: 0; left: 0; width: 100vw; height: 100vh; z-index: 1; }

        /* UI OVERLAY */
        #ui-layer {
            position: absolute; z-index: 10; width: 100%; height: 100%; pointer-events: none;
            display: flex; flex-direction: column; justify-content: space-between;
        }

        /* Top Bar */
        .top-bar {
            background: linear-gradient(to bottom, black, transparent);
            padding: 15px; pointer-events: auto; display: flex; gap: 10px;
        }
        
        #search-input {
            flex-grow: 1; background: rgba(255,255,255,0.1); border: 1px solid var(--hud-color);
            color: var(--hud-color); padding: 10px; border-radius: 5px; font-weight: bold;
            backdrop-filter: blur(5px);
        }
        #search-input::placeholder { color: rgba(0, 243, 255, 0.5); }

        #search-results {
            position: absolute; top: 60px; left: 15px; right: 15px;
            background: var(--bg-glass); border: 1px solid var(--hud-color);
            max-height: 50vh; overflow-y: auto; display: none;
        }
        .result-item { padding: 12px; border-bottom: 1px solid #333; cursor: pointer; display: flex; justify-content: space-between; }
        .result-item small { color: #888; }
        .result-item:hover { background: rgba(0, 243, 255, 0.1); }

        /* HUD Elements */
        .reticle {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            width: 40px; height: 40px; border: 1px solid rgba(255,255,255,0.3); border-radius: 50%;
            pointer-events: none;
        }
        .reticle::after { content: '+'; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: var(--hud-color); }

        .target-indicator {
            position: absolute; width: 60px; height: 60px;
            border: 2px solid var(--alert-color); border-radius: 5px;
            transform: translate(-50%, -50%); display: none;
            box-shadow: 0 0 15px var(--alert-color);
            transition: all 0.1s;
        }

        /* Bottom Info */
        .bottom-bar {
            background: linear-gradient(to top, black, transparent);
            padding: 20px; text-align: center; pointer-events: auto;
        }
        .data-readout { font-family: monospace; color: var(--hud-color); font-size: 12px; margin-bottom: 5px; }
        .obj-title { font-size: 24px; font-weight: bold; letter-spacing: 2px; text-shadow: 0 0 10px var(--hud-color); }

        /* Loading / Start */
        #splash {
            position: fixed; inset: 0; background: #000; z-index: 100;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            pointer-events: auto; text-align: center;
        }
        .btn {
            margin-top: 20px; padding: 15px 40px; background: transparent;
            border: 2px solid var(--hud-color); color: var(--hud-color);
            font-size: 18px; cursor: pointer; text-transform: uppercase;
            box-shadow: 0 0 15px rgba(0,243,255,0.3);
        }
        .btn:hover { background: var(--hud-color); color: black; }
        
        .calibration-hint {
            position: absolute; bottom: 100px; width: 100%; text-align: center;
            color: #888; font-size: 12px; pointer-events: none; opacity: 0.7;
        }

    </style>
    <!-- Import Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Rajdhani:wght@400;600&display=swap" rel="stylesheet">
</head>
<body>

    <div id="splash">
        <h1 style="font-size: 40px; margin:0;">ORION <span style="color:var(--hud-color)">TRACKER</span></h1>
        <p id="status-text" style="color:#aaa;">Waiting for user...</p>
        <button class="btn" onclick="initSystem()">Initialize Sensors</button>
        <p style="font-size: 11px; color:#555; margin-top:20px;">Requires GPS & HTTPS</p>
    </div>

    <div id="ui-layer">
        <div class="top-bar">
            <input type="text" id="search-input" placeholder="SEARCH OBJECTS..." autocomplete="off">
        </div>
        <div id="search-results"></div>
        
        <div class="reticle"></div>
        <div class="target-indicator" id="lock-box"></div>

        <div class="calibration-hint">DRAG SCREEN LEFT/RIGHT TO CALIBRATE COMPASS</div>

        <div class="bottom-bar">
            <div class="data-readout" id="debug-coords">AZ: 000 | EL: 00</div>
            <div class="obj-title" id="hud-name">SCANNING</div>
            <div class="data-readout" id="hud-details">System Ready</div>
        </div>
    </div>

    <div id="canvas-container"></div>

    <!-- Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Astronomy Engine: Handles precise planet calculations -->
    <script src="https://cdn.jsdelivr.net/npm/astronomy-engine@2.1.19/astronomy.browser.min.js"></script>

    <script>
        // --- CONFIGURATION ---
        const CONFIG = {
            fov: 75,
            sensorSmoothing: 0.15, // Lower = smoother but more lag
            starCount: 2000,
            calibrateSensitivity: 0.005
        };

        // --- STATE ---
        let appState = {
            lat: 0,
            lon: 0,
            time: new Date(),
            calibOffset: 0, // Manual compass offset
            target: null,   // Currently tracked object
            isTracking: false
        };

        const BODIES = [
            "Sun", "Moon", "Mercury", "Venus", "Mars", "Jupiter", "Saturn", "Uranus", "Neptune"
        ];

        // Static Database for Stars (subset of bright stars)
        // RA in hours, Dec in degrees
        const STARS_DB = [
            { name: "Sirius", ra: 6.75, dec: -16.71, mag: -1.46, color: 0xaabfff },
            { name: "Canopus", ra: 6.40, dec: -52.69, mag: -0.74, color: 0xffffee },
            { name: "Arcturus", ra: 14.26, dec: 19.18, mag: -0.05, color: 0xffddb4 },
            { name: "Vega", ra: 18.62, dec: 38.78, mag: 0.03, color: 0xcad8ff },
            { name: "Rigel", ra: 5.24, dec: -8.20, mag: 0.13, color: 0xaabfff },
            { name: "Betelgeuse", ra: 5.92, dec: 7.41, mag: 0.45, color: 0xffaa88 },
            { name: "Capella", ra: 5.27, dec: 45.99, mag: 0.08, color: 0xfff4e8 },
            { name: "Aldebaran", ra: 4.60, dec: 16.51, mag: 0.87, color: 0xffbd6f },
            { name: "Antares", ra: 16.49, dec: -26.43, mag: 0.96, color: 0xff4422 },
            { name: "Polaris", ra: 2.53, dec: 89.26, mag: 1.97, color: 0xffffee },
            { name: "Andromeda Galaxy", ra: 0.71, dec: 41.26, mag: 3.4, color: 0xccddff, type: "Galaxy" },
            { name: "Pleiades", ra: 3.79, dec: 24.11, mag: 1.6, color: 0x88ccff, type: "Cluster" }
        ];

        let scene, camera, renderer, guideArrow;
        let celestialGroup; // Holds all stars/planets
        let objectMeshes = []; 
        let deviceQuaternion = new THREE.Quaternion();

        // --- INITIALIZATION ---

        async function initSystem() {
            const status = document.getElementById('status-text');
            
            // 1. Get GPS
            status.innerText = "Acquiring GPS...";
            if ("geolocation" in navigator) {
                navigator.geolocation.getCurrentPosition(pos => {
                    appState.lat = pos.coords.latitude;
                    appState.lon = pos.coords.longitude;
                    status.innerText = `GPS Locked: ${appState.lat.toFixed(2)}, ${appState.lon.toFixed(2)}`;
                    
                    // 2. Request Sensors (iOS 13+)
                    requestSensors();

                }, err => {
                    alert("GPS Denied. Using Default (0,0). Accuracy will be off.");
                    requestSensors();
                });
            } else {
                alert("GPS not available.");
                requestSensors();
            }
        }

        function requestSensors() {
            if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
                DeviceOrientationEvent.requestPermission()
                    .then(response => {
                        if (response === 'granted') start3D();
                        else alert("Sensor permission denied.");
                    })
                    .catch(console.error);
            } else {
                start3D();
            }
        }

        function start3D() {
            document.getElementById('splash').style.display = 'none';
            
            // Three.js Setup
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(CONFIG.fov, window.innerWidth / window.innerHeight, 0.1, 2000);
            
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // Celestial Group: We will rotate THIS based on Sidereal time, not the individual stars
            celestialGroup = new THREE.Group();
            scene.add(celestialGroup);

            // Populate Universe
            createStarField();
            createRealTimeObjects();
            createMilkyWay();
            createGuideArrow();

            // Inputs
            window.addEventListener('deviceorientation', onDeviceOrientation);
            window.addEventListener('resize', onResize);
            
            // Touch for calibration
            let startX = 0;
            document.addEventListener('touchstart', e => startX = e.touches[0].clientX);
            document.addEventListener('touchmove', e => {
                const delta = e.touches[0].clientX - startX;
                appState.calibOffset += delta * CONFIG.calibrateSensitivity * 0.01;
                startX = e.touches[0].clientX;
            });

            animate();
            
            // UI Search Listener
            setupSearch();
        }

        // --- ASTRONOMY MATH ---

        function updateCelestialPositions() {
            const date = new Date();
            const observer = new Astronomy.Observer(appState.lat, appState.lon, 0);

            // 1. Calculate Sidereal Time (Rotation of the Earth)
            // We need to rotate the celestial sphere so RA matches current sky
            // Astronomy engine gives us position relative to Earth. 
            // We'll calculate Equatorial coordinates (J2000) and place them in the scene.
            // Then we simply align the camera to North.
            
            // Actually, simpler approach for 3D engine:
            // 1. Place stars at J2000 RA/Dec on a sphere.
            // 2. Rotate the Sphere Container by the negative of Local Apparent Sidereal Time (LAST).
            // 3. User stands inside sphere.
            
            // But Astronomy.js gives easy Horizontal coordinates (Az/El). 
            // However, Az/El changes every second. RA/Dec is fairly fixed.
            // Let's stick to RA/Dec (Equatorial) and rotate the container.
            
            // Update Planets (They move relative to background stars)
            BODIES.forEach(name => {
                // Get Equatorial Coordinates
                const equ = Astronomy.Equator(name, date, observer, true, true);
                const mesh = objectMeshes.find(m => m.userData.name === name);
                
                if (mesh) {
                    const pos = raDecToVector(equ.ra, equ.dec, mesh.userData.dist || 400);
                    mesh.position.copy(pos);
                }
            });
        }

        // Convert RA (hours) and Dec (degrees) to Cartesian XYZ
        // In Three.js (Y-up):
        // Y = Celestial North Pole (Dec = 90)
        // Z = RA 0 (Vernal Equinox) roughly
        function raDecToVector(ra, dec, radius) {
            const phi = (90 - dec) * (Math.PI / 180); // Polar angle
            const theta = (ra * 15) * (Math.PI / 180) - Math.PI/2; // Azimuthal angle (RA hrs -> deg -> rad)
            // -PI/2 aligns RA 0 with Z axis in typical math, adjust for Three.js
            
            const x = radius * Math.sin(phi) * Math.cos(theta); 
            const y = radius * Math.cos(phi); // Y is Up/North
            const z = radius * Math.sin(phi) * Math.sin(theta);
            
            return new THREE.Vector3(x, y, z);
        }

        // --- SCENE BUILDING ---

        function createRealTimeObjects() {
            // 1. Planets & Sun/Moon
            BODIES.forEach(name => {
                let size = 2, color = 0xffffff, dist = 400;
                if (name === "Sun") { size = 15; color = 0xffff00; dist = 450; }
                else if (name === "Moon") { size = 10; color = 0xeeeeee; dist = 380; }
                else if (name === "Jupiter") { size = 6; color = 0xdca975; }
                else if (name === "Mars") { size = 3; color = 0xff4500; }

                const geo = new THREE.SphereGeometry(size, 16, 16);
                const mat = new THREE.MeshBasicMaterial({ color: color });
                const mesh = new THREE.Mesh(geo, mat);
                
                mesh.userData = { name: name, type: "Planet", dist: dist };
                celestialGroup.add(mesh);
                objectMeshes.push(mesh);

                // Add Glow
                if(name === "Sun"){
                    const glow = new THREE.Mesh(
                        new THREE.SphereGeometry(size*2, 16, 16),
                        new THREE.MeshBasicMaterial({color: color, transparent: true, opacity: 0.3})
                    );
                    mesh.add(glow);
                }
            });

            // 2. Stars from DB
            STARS_DB.forEach(star => {
                const geo = new THREE.SphereGeometry(star.mag < 0 ? 3 : 1.5, 8, 8);
                const mat = new THREE.MeshBasicMaterial({ color: star.color });
                const mesh = new THREE.Mesh(geo, mat);
                
                // Static J2000 positions
                mesh.position.copy(raDecToVector(star.ra, star.dec, 500));
                
                mesh.userData = { name: star.name, type: star.type || "Star" };
                celestialGroup.add(mesh);
                objectMeshes.push(mesh);
            });
        }

        function createStarField() {
            const geo = new THREE.BufferGeometry();
            const pos = [];
            for(let i=0; i<3000; i++) {
                const r = 600;
                const theta = 2 * Math.PI * Math.random();
                const phi = Math.acos(2 * Math.random() - 1);
                pos.push(
                    r * Math.sin(phi) * Math.cos(theta),
                    r * Math.sin(phi) * Math.sin(theta),
                    r * Math.cos(phi)
                );
            }
            geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
            const mat = new THREE.PointsMaterial({ size: 1.5, color: 0x555555 });
            const points = new THREE.Points(geo, mat);
            celestialGroup.add(points); // Background stars move with the sky rotation
        }

        function createMilkyWay() {
             // Simplified band
             const geo = new THREE.CylinderGeometry(550, 550, 100, 32, 1, true);
             const mat = new THREE.MeshBasicMaterial({ 
                 color: 0x4422aa, side: THREE.BackSide, transparent: true, opacity: 0.1,
                 blending: THREE.AdditiveBlending 
             });
             const mw = new THREE.Mesh(geo, mat);
             // Orient roughly along galactic plane (simplified)
             mw.rotation.x = Math.PI / 2; 
             mw.rotation.z = Math.PI / 3;
             celestialGroup.add(mw);
        }

        function createGuideArrow() {
            const geo = new THREE.ConeGeometry(5, 20, 8);
            geo.rotateX(Math.PI / 2); // Point along Z
            const mat = new THREE.MeshBasicMaterial({ color: 0x00f3ff, transparent: true, opacity: 0.8 });
            guideArrow = new THREE.Mesh(geo, mat);
            scene.add(guideArrow);
            guideArrow.visible = false;
        }

        // --- CORE LOOP ---

        function onDeviceOrientation(e) {
            // Convert device alpha/beta/gamma to Three.js quaternion
            // Alpha: Compass (0-360), Beta: Tilt F/B, Gamma: Tilt L/R
            const alpha = e.alpha ? THREE.MathUtils.degToRad(e.alpha + appState.calibOffset * 100) : 0; 
            const beta = e.beta ? THREE.MathUtils.degToRad(e.beta) : 0;
            const gamma = e.gamma ? THREE.MathUtils.degToRad(e.gamma) : 0;
            const orient = window.orientation ? THREE.MathUtils.degToRad(window.orientation) : 0;

            const euler = new THREE.Euler(beta, alpha, -gamma, 'YXZ');
            const q1 = new THREE.Quaternion(-Math.sqrt(0.5), 0, 0, Math.sqrt(0.5)); // -X 90deg
            
            const q = new THREE.Quaternion();
            q.setFromEuler(euler);
            q.multiply(q1);
            
            // Handle screen rotation
            const qOrient = new THREE.Quaternion();
            qOrient.setFromAxisAngle(new THREE.Vector3(0,0,1), -orient);
            q.multiply(qOrient);

            // Store for smoothing in animate loop
            deviceQuaternion.copy(q);
        }

        function updateSkyRotation() {
            // Rotate the entire CelestialGroup based on Sidereal Time + Latitude
            // This aligns the J2000 coordinates with the current local sky
            
            const date = new Date();
            // Calculate Local Apparent Sidereal Time (LAST) in degrees
            // Astronomy Engine returns greenwich apparent sidereal time, we add lon
            const gast = Astronomy.SiderealTime(date); // Greenwich Sidereal Time in hours
            const last = (gast * 15) + appState.lon; // Local Sidereal Time in degrees

            // 1. Reset rotation
            celestialGroup.rotation.set(0,0,0);

            // 2. Rotate for Sidereal Time (Earth's spin) around Y (North Pole in our scene)
            // Stars move East to West -> Rotate sky West to East
            // But wait, in Three.js, Y is up.
            // If we look at Z+, and rotate Y, it spins.
            // Correct mapping:
            // Rotate celestial sphere around World Y axis by -LAST
            celestialGroup.rotateY(THREE.MathUtils.degToRad(-last));
            
            // 3. Adjust for Latitude?
            // Actually, the DeviceOrientation controls the camera relative to the Horizon.
            // The Celestial Sphere is aligned with the Earth's Axis (North/South poles).
            // So Y axis of the scene IS the Earth's axis.
            // But the User is standing on the surface.
            // The DeviceOrientation provides rotation relative to the Local Tangent Plane (Horizon).
            // This is the tricky part.
            
            // Standard approach:
            // Scene Y = North Pole.
            // Camera needs to be rotated by Latitude to align 'Up' with Zenith.
            // But DeviceOrientation assumes phone is level with ground.
            
            // Let's invert the thinking:
            // Keep Camera handling device rotation (which is relative to North/Horizon).
            // Rotate the Celestial Group such that its "North Pole" aligns with True North 
            // and its height aligns with Latitude.
            
            // Correct Setup:
            // 1. Align Celestial Sphere Y to World Y.
            // 2. Rotate Celestial Sphere by -LAST (Sidereal) around Y.
            // 3. Now, we need to tilt the whole group so that the North Pole (Scene Y)
            //    is at the correct altitude for the observer.
            //    North Star Altitude = Observer Latitude.
            //    But DeviceOrientation 'Forward' (Z-) is usually North if alpha=0.
            
            // To simplify: We will rotate the **Container** of the stars.
            // If Lat = 90 (North Pole), Polaris is Overhead.
            // If Lat = 0 (Equator), Polaris is at Horizon.
            
            // The logic involves matrix transforms that are complex for a single file.
            // Hack fix for this demo:
            // Rotate CelestialGroup by (90 - Lat) around X axis?
            // Let's rely on Astronomy.js Horizon coordinates to debug.
            
            // Actually, Astronomy.js gives us reliable Topocentric RA/Dec.
            // If we just plot RA/Dec on a sphere where Y=North, 
            // We just need to ensure the Camera Y-axis points to Zenith? 
            // No, DeviceOrientation logic creates a camera where Y is 'Up' relative to phone, not world.
            
            // WORKING MODEL:
            // 1. Celestial Sphere is fixed to Earth Axis (Y=North).
            // 2. Rotate Sphere by -LAST around Y.
            // 3. Rotate Sphere by (90 - Latitude) around X.
            // This places the Sky correctly relative to a "World" where Y is Zenith and Z is North.
            
            // Reset
            celestialGroup.quaternion.set(0,0,0);
            
            // Apply Sidereal Rotation (Spinning Earth)
            // The sky rotates around the Pole (Y axis)
            const radLAST = THREE.MathUtils.degToRad(last);
            const qSidereal = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), -radLAST);
            celestialGroup.quaternion.multiply(qSidereal);

            // Apply Latitude Tilt
            // We need to tilt the North Pole (Y) down to the North Horizon.
            // If we are at Equator (Lat 0), North Pole is at Horizon. We rotate 90 deg.
            // If we are at North Pole (Lat 90), North Pole is Up. We rotate 0 deg.
            const latCorrection = THREE.MathUtils.degToRad(90 - appState.lat);
            const qLat = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(1, 0, 0), latCorrection);
            
            // Order matters: Spin then Tilt? Or Tilt then Spin?
            // The axis of rotation (Earth Axis) is what's tilted relative to the observer.
            // So we tilt the whole system.
            celestialGroup.quaternion.premultiply(qLat); 
        }

        // --- TRACKING & GUIDANCE ---

        function setupSearch() {
            const input = document.getElementById('search-input');
            const res = document.getElementById('search-results');
            
            input.addEventListener('input', e => {
                const val = e.target.value.toLowerCase();
                res.innerHTML = '';
                if(val.length < 2) { res.style.display='none'; return; }
                
                const all = [...BODIES.map(n=>({name:n, type:'Planet'})), ...STARS_DB];
                const matches = all.filter(o => o.name.toLowerCase().includes(val));
                
                if(matches.length){
                    res.style.display='block';
                    matches.forEach(m => {
                        const div = document.createElement('div');
                        div.className = 'result-item';
                        div.innerHTML = `<span>${m.name}</span><small>${m.type}</small>`;
                        div.onclick = () => {
                            lockTarget(m.name);
                            res.style.display='none';
                            input.value = '';
                        };
                        res.appendChild(div);
                    });
                }
            });
        }

        function lockTarget(name) {
            appState.isTracking = true;
            appState.target = name;
            guideArrow.visible = true;
            document.getElementById('hud-name').innerText = "TRACKING: " + name.toUpperCase();
        }

        function updateGuidance() {
            if(!appState.isTracking || !appState.target) return;
            
            const mesh = objectMeshes.find(m => m.userData.name === appState.target);
            if(!mesh) return;

            // 1. Arrow Guidance
            // Arrow position: slightly in front of camera
            const camDir = new THREE.Vector3();
            camera.getWorldDirection(camDir);
            const arrowPos = camera.position.clone().add(camDir.multiplyScalar(20));
            guideArrow.position.copy(arrowPos);
            
            // Arrow look at target
            // Use world position of target
            const targetPos = new THREE.Vector3();
            mesh.getWorldPosition(targetPos);
            guideArrow.lookAt(targetPos);

            // 2. HUD Lock Box
            // Project 3D pos to 2D screen
            const width = window.innerWidth, height = window.innerHeight;
            const pos = targetPos.clone().project(camera);

            const lockBox = document.getElementById('lock-box');
            
            // Check if in front of camera and inside screen bounds
            if (pos.z < 1 && pos.x > -0.9 && pos.x < 0.9 && pos.y > -0.9 && pos.y < 0.9) {
                const x = (pos.x * .5 + .5) * width;
                const y = (pos.y * -.5 + .5) * height;
                lockBox.style.display = 'block';
                lockBox.style.left = x + 'px';
                lockBox.style.top = y + 'px';
                guideArrow.visible = false; // Hide arrow when locked
            } else {
                lockBox.style.display = 'none';
                guideArrow.visible = true; // Show arrow when lost
            }
        }

        // --- ANIMATION ---

        function animate() {
            requestAnimationFrame(animate);

            // 1. Smooth Camera Movement (SLERP)
            camera.quaternion.slerp(deviceQuaternion, CONFIG.sensorSmoothing);

            // 2. Update Physics
            updateCelestialPositions(); // Recalculate planet positions
            updateSkyRotation();        // Rotate the universe for Sidereal Time

            // 3. UI Updates
            updateGuidance();
            
            // Debug info
            const dir = new THREE.Vector3();
            camera.getWorldDirection(dir);
            // Rough conversion to Azimuth for debug
            const az = Math.abs(Math.atan2(dir.x, dir.z) * 180 / Math.PI);
            document.getElementById('debug-coords').innerText = `CALIB: ${appState.calibOffset.toFixed(1)} | AZ: ${az.toFixed(0)}`;

            renderer.render(scene, camera);
        }
        
        function onResize(){
            camera.aspect = window.innerWidth/window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

    </script>
</body>
</html>
