<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Starry Night</title>
    <style>
        :root { --accent: #4deeea; --glass: rgba(12, 12, 20, 0.85); }
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Segoe UI', system-ui, sans-serif; user-select: none; -webkit-user-select: none; }
        
        /* 3D Viewport */
        #viewport { position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; background: radial-gradient(circle at bottom, #111933 0%, #000000 100%); }

        /* UI Overlay */
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 10; pointer-events: none; display: flex; flex-direction: column; }
        
        /* Header / Search */
        .top-bar { padding: 15px; background: linear-gradient(to bottom, rgba(0,0,0,0.9), transparent); pointer-events: auto; }
        .search-wrapper { position: relative; max-width: 400px; margin: 0 auto; }
        input#search { 
            width: 100%; padding: 12px 20px; border-radius: 30px; border: 1px solid rgba(255,255,255,0.3);
            background: var(--glass); backdrop-filter: blur(8px); color: white; outline: none; transition: 0.3s;
        }
        input#search:focus { border-color: var(--accent); box-shadow: 0 0 15px rgba(77, 238, 234, 0.3); }
        
        #results {
            position: absolute; top: 55px; left: 0; right: 0; background: rgba(10,10,15,0.95);
            border-radius: 15px; border: 1px solid #333; max-height: 50vh; overflow-y: auto; display: none;
        }
        .item { padding: 15px; border-bottom: 1px solid #222; color: #eee; cursor: pointer; display: flex; justify-content: space-between; }
        .item span.type { font-size: 0.75em; color: #888; text-transform: uppercase; letter-spacing: 1px; }

        /* Targeting Reticle */
        #reticle {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            width: 70px; height: 70px; border: 1px solid rgba(255,255,255,0.3); border-radius: 50%;
            opacity: 0; transition: 0.3s; pointer-events: none;
        }
        #reticle.active { opacity: 1; border-color: var(--accent); box-shadow: 0 0 20px var(--accent); border-width: 2px; }
        
        #arrow-guide {
            position: absolute; top: 50%; left: 50%; width: 0; height: 0; pointer-events: none; display: none;
        }
        .arrow {
            width: 0; height: 0; border-left: 10px solid transparent; border-right: 10px solid transparent;
            border-bottom: 25px solid var(--accent); transform: translate(-50%, -100px);
            filter: drop-shadow(0 0 8px var(--accent));
        }

        /* Footer */
        .footer { margin-top: auto; padding: 20px; text-align: center; pointer-events: auto; background: linear-gradient(to top, rgba(0,0,0,0.9), transparent); }
        .compass { 
            width: 60px; height: 60px; border: 2px solid rgba(255,255,255,0.2); border-radius: 50%; margin: 0 auto;
            position: relative; display: flex; align-items: center; justify-content: center; background: rgba(0,0,0,0.4);
        }
        .compass-needle { width: 2px; height: 20px; background: var(--accent); position: absolute; top: 5px; transform-origin: bottom center; }
        .dir { position: absolute; font-size: 10px; color: #aaa; font-weight: bold; }
        .n { top: 2px; color: var(--accent); } .s { bottom: 2px; } .e { right: 4px; } .w { left: 4px; }
        .info { font-size: 11px; color: #777; margin-top: 10px; }

        /* Splash Screen */
        #splash {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 1000;
            background: #000; display: flex; flex-direction: column; align-items: center; justify-content: center;
        }
        h1 { font-weight: 300; letter-spacing: 5px; font-size: 2.5rem; background: linear-gradient(to right, #fff, var(--accent)); -webkit-background-clip: text; -webkit-text-fill-color: transparent; margin-bottom: 5px; }
        button.start-btn {
            margin-top: 40px; padding: 15px 50px; border-radius: 30px; border: none;
            background: white; color: black; font-weight: bold; font-size: 16px; cursor: pointer;
            box-shadow: 0 0 25px rgba(255,255,255,0.2); transition: 0.2s;
        }
        button.start-btn:active { transform: scale(0.95); }
        .warning { color: #ff4444; font-size: 12px; margin-top: 20px; display: none; max-width: 80%; text-align: center; }

    </style>
</head>
<body>

    <div id="splash">
        <h1>STARRY NIGHT</h1>
        <p style="color: #666; font-size: 0.9rem;">Realtime AR Sky Map</p>
        <button class="start-btn" id="btn-enter">Start Stargazing</button>
        <div id="https-warn" class="warning">Warning: Not using HTTPS. Sensors may not work.</div>
        <div style="font-size: 10px; color: #444; margin-top: 30px;">Point device at the sky</div>
    </div>

    <div id="ui-layer">
        <div class="top-bar">
            <div class="search-wrapper">
                <input type="text" id="search" placeholder="Find stars, planets, galaxies..." autocomplete="off">
                <div id="results"></div>
            </div>
        </div>

        <div id="reticle"></div>
        <div id="arrow-guide"><div class="arrow"></div></div>

        <div class="footer">
            <div class="compass" id="compass-ui">
                <div class="dir n">N</div><div class="dir s">S</div><div class="dir e">E</div><div class="dir w">W</div>
                <div class="compass-needle"></div>
            </div>
            <div class="info" id="gps-status">Locating...</div>
        </div>
    </div>

    <div id="viewport"></div>

    <!-- Imports -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "astronomy-engine": "https://unpkg.com/astronomy-engine@2.0.0/esm/index.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import * as Astronomy from 'astronomy-engine';

        // --- Config ---
        const DIST_STARS = 1000;
        const DIST_PLANETS = 900;
        
        // State
        const state = {
            lat: 0,
            lon: 0,
            hasGPS: false,
            target: null,
            drag: { x: 0, y: 0, active: false, startX: 0, startY: 0 },
            manualOffset: { x: 0, y: 0 } // For desktop mouse looking
        };

        const celestialDB = [];

        // Three.js Globals
        let scene, camera, renderer;
        let starGroup, solarGroup, worldGroup;

        // --- Entry Point ---
        const btnEnter = document.getElementById('btn-enter');
        
        // Check HTTPS
        if (location.protocol !== 'https:' && location.hostname !== 'localhost' && location.hostname !== '127.0.0.1') {
            document.getElementById('https-warn').style.display = 'block';
        }

        btnEnter.addEventListener('click', async () => {
            // 1. Hide Splash immediately (Prevents getting stuck)
            document.getElementById('splash').style.opacity = 0;
            setTimeout(() => document.getElementById('splash').style.display = 'none', 500);

            // 2. Request Permissions (iOS)
            if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
                try { await DeviceOrientationEvent.requestPermission(); } catch (e) { console.log("Perms error", e); }
            }

            // 3. Start Geolocation (Async)
            if (navigator.geolocation) {
                navigator.geolocation.getCurrentPosition(
                    (pos) => {
                        state.lat = pos.coords.latitude;
                        state.lon = pos.coords.longitude;
                        state.hasGPS = true;
                        document.getElementById('gps-status').innerText = `Lat: ${state.lat.toFixed(2)} | Lon: ${state.lon.toFixed(2)}`;
                        updateCelestialPositions(); // Re-calc based on new location
                    },
                    (err) => {
                        document.getElementById('gps-status').innerText = "GPS Failed. Using Default (0,0)";
                    }
                );
            }

            // 4. Start App
            init3D();
            window.addEventListener('deviceorientation', handleOrientation);
            setupTouchControls();
        });

        // --- 3D Engine ---
        function init3D() {
            const container = document.getElementById('viewport');
            
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x020205, 0.0005); // Atmospheric haze

            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 2000);
            
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            container.appendChild(renderer.domElement);

            // Groups
            worldGroup = new THREE.Group(); // Rotates for Latitude
            scene.add(worldGroup);
            
            starGroup = new THREE.Group(); // Rotates for Time (Sidereal)
            worldGroup.add(starGroup);

            solarGroup = new THREE.Group(); // Planets
            worldGroup.add(solarGroup);

            // Helpers
            const grid = new THREE.PolarGridHelper(DIST_STARS, 24, 8, 64, 0x112233, 0x000000);
            scene.add(grid); // Horizon grid (Fixed to scene/ground)

            // Content
            generateStars();
            generateMilkyWay();
            updateCelestialPositions(); // Initial calc

            animate();

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        // --- Data & Generation ---
        
        // Helper: Create Text Label (Positioned BELOW object)
        function createLabel(text, color, scaleFactor=1) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            const fontSize = 24;
            ctx.font = `bold ${fontSize}px sans-serif`;
            const textW = ctx.measureText(text).width;
            canvas.width = textW + 20;
            canvas.height = fontSize + 20;
            
            ctx.fillStyle = color;
            ctx.font = `bold ${fontSize}px sans-serif`;
            ctx.shadowColor = 'black'; ctx.shadowBlur = 4;
            ctx.fillText(text, 10, fontSize);

            const tex = new THREE.CanvasTexture(canvas);
            const mat = new THREE.SpriteMaterial({ map: tex, transparent: true, depthTest: false });
            const sprite = new THREE.Sprite(mat);
            
            // center.y = 1.0 sets the anchor at the Top of the sprite.
            // This makes the text hang BELOW the coordinate point.
            sprite.center.set(0.5, 1.3); 
            
            const s = 0.5 * (fontSize/10) * scaleFactor;
            sprite.scale.set(s * (canvas.width/canvas.height), s, 1);
            return sprite;
        }

        function raDecToVec(ra, dec, r) {
            // RA (Hours) -> Rad, Dec (Deg) -> Rad
            const phi = (ra * 15) * (Math.PI/180);
            const theta = dec * (Math.PI/180);
            const x = r * Math.cos(theta) * Math.sin(phi);
            const y = r * Math.sin(theta);
            const z = r * Math.cos(theta) * Math.cos(phi);
            return new THREE.Vector3(-x, y, -z);
        }

        function generateStars() {
            // 1. Procedural Background
            const geometry = new THREE.BufferGeometry();
            const vertices = [];
            const colors = [];
            const color = new THREE.Color();
            
            for(let i=0; i<3000; i++) {
                const r = DIST_STARS * (0.8 + Math.random()*0.4);
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                vertices.push(
                    r * Math.sin(phi) * Math.cos(theta),
                    r * Math.sin(phi) * Math.sin(theta),
                    r * Math.cos(phi)
                );
                
                // Color variation
                const t = Math.random();
                if(t>0.9) color.setHex(0xffaa88); // Red
                else if(t>0.7) color.setHex(0xffffaa); // Yellow
                else color.setHex(0xaaccff); // Blue-white
                colors.push(color.r, color.g, color.b);
            }
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            const stars = new THREE.Points(geometry, new THREE.PointsMaterial({ size: 2, vertexColors: true, transparent:true, opacity:0.8, sizeAttenuation: false }));
            starGroup.add(stars);

            // 2. Bright Stars Catalog
            const catalog = [
                ["Sirius",6.75,-16.7,"#aaddff",1.5], ["Canopus",6.4,-52.7,"#ffffff",1.4], ["Arcturus",14.26,19.1,"#ffccaa",1.3],
                ["Vega",18.62,38.8,"#aaddff",1.3], ["Capella",5.27,46.0,"#ffffaa",1.3], ["Rigel",5.24,-8.2,"#ccccff",1.3],
                ["Procyon",7.65,5.2,"#ffffff",1.2], ["Betelgeuse",5.92,7.4,"#ff8866",1.4], ["Altair",19.85,8.9,"#ffffff",1.2],
                ["Aldebaran",4.6,16.5,"#ffaa55",1.2], ["Antares",16.49,-26.4,"#ff4433",1.2], ["Spica",13.42,-11.2,"#aaaaff",1.2],
                ["Pollux",7.76,28.0,"#ffccaa",1.1], ["Deneb",20.69,45.3,"#ffffff",1.1], ["Regulus",10.14,11.9,"#aaaaff",1.1],
                ["Castor",7.58,31.9,"#ffffff",1.0], ["Polaris",2.53,89.3,"#ffffdd",1.2],
                // Deep Sky
                ["Andromeda Galaxy",0.71,41.26,"#ddeeFF", 3.0, "Galaxy"], 
                ["Orion Nebula",5.58,-5.39,"#ffccff", 3.0, "Nebula"],
                ["Pleiades",3.78,24.1,"#aabbff", 2.5, "Cluster"]
            ];

            // Texture for stars
            const cvs = document.createElement('canvas'); cvs.width=32; cvs.height=32;
            const cx = cvs.getContext('2d');
            const g = cx.createRadialGradient(16,16,0,16,16,16);
            g.addColorStop(0, 'white'); g.addColorStop(0.4, 'rgba(255,255,255,0.5)'); g.addColorStop(1, 'transparent');
            cx.fillStyle=g; cx.fillRect(0,0,32,32);
            const tex = new THREE.CanvasTexture(cvs);

            catalog.forEach(item => {
                const [name, ra, dec, col, scale, type] = item;
                const pos = raDecToVec(ra, dec, DIST_STARS);
                
                // Sprite
                const mat = new THREE.SpriteMaterial({ map: tex, color: col });
                const sprite = new THREE.Sprite(mat);
                sprite.position.copy(pos);
                sprite.scale.setScalar(20 * scale);
                starGroup.add(sprite);

                // Label
                const label = createLabel(name, col);
                label.position.copy(pos);
                starGroup.add(label);

                celestialDB.push({ name: name, type: type || 'Star', pos: pos, group: starGroup });
            });
        }

        function generateMilkyWay() {
            const count = 4000;
            const geo = new THREE.BufferGeometry();
            const pos = [];
            for(let i=0; i<count; i++) {
                const r = DIST_STARS * 0.9;
                const angle = Math.random() * Math.PI * 2;
                const spread = (Math.random()-0.5) * 300;
                
                const v = new THREE.Vector3(r*Math.cos(angle), spread, r*Math.sin(angle));
                v.applyAxisAngle(new THREE.Vector3(1,0,0), 60*Math.PI/180); // Tilt galactic plane
                pos.push(v.x, v.y, v.z);
            }
            geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
            const mat = new THREE.PointsMaterial({ color: 0x554466, size: 4, transparent: true, opacity: 0.2, blending: THREE.AdditiveBlending, sizeAttenuation: false });
            starGroup.add(new THREE.Points(geo, mat));
        }

        function updateCelestialPositions() {
            // Real-time Solar System Update
            const date = new Date();
            const observer = new Astronomy.Observer(state.lat, state.lon, 0);
            
            // Clear planets if exist
            while(solarGroup.children.length>0) solarGroup.remove(solarGroup.children[0]);

            const planets = [
                {k:"Sun", c:"#ffaa00", s:60}, {k:"Moon", c:"#eeeeee", s:40},
                {k:"Mars", c:"#ff5533", s:25}, {k:"Jupiter", c:"#ffcc99", s:40},
                {k:"Saturn", c:"#eebb88", s:35}, {k:"Venus", c:"#ffffff", s:30}
            ];

            planets.forEach(p => {
                const body = Astronomy.Body[p.k];
                const eq = Astronomy.Equator(body, date, observer, true, true);
                const pos = raDecToVec(eq.ra, eq.dec, DIST_PLANETS);

                // Planet Mesh
                const geo = new THREE.SphereGeometry(1, 16, 16);
                const mat = new THREE.MeshBasicMaterial({ color: p.c });
                const mesh = new THREE.Mesh(geo, mat);
                mesh.position.copy(pos);
                mesh.scale.setScalar(p.s/2); // Physical sphere size
                solarGroup.add(mesh);

                // Glow Sprite
                const sprite = createLabel("", p.c); // Reusing label function just for texture? No, create simple sprite
                // ...simple glow logic omitted for brevity, adding Label instead
                
                // Label
                const label = createLabel(p.k, p.c);
                label.position.copy(pos);
                solarGroup.add(label);

                // Add to Search
                // Remove old entries first if re-calculating? 
                // For simplicity in this standalone, we just push (might duplicate over time if re-running often, but fine for single session)
                if(!celestialDB.find(x => x.name === p.k)) {
                    celestialDB.push({ name: p.k, type: p.k==="Sun"?"Star":p.k==="Moon"?"Moon":"Planet", pos: pos, group: solarGroup });
                } else {
                    // Update pos of existing
                    const existing = celestialDB.find(x => x.name === p.k);
                    existing.pos = pos;
                }
            });

            // Rotate Groups for Time & Latitude
            // 1. Sidereal Time Rotation (Sky spins East-West)
            const gst = Astronomy.SiderealTime(date); 
            const lst = gst + state.lon/15.0; 
            const rotY = -(lst * 15 * Math.PI/180) - Math.PI/2;
            
            starGroup.rotation.y = rotY;
            solarGroup.rotation.y = rotY;

            // 2. Latitude Rotation (Polar axis alignment)
            worldGroup.rotation.x = (90 - state.lat) * (Math.PI/180);
        }

        // --- Interaction ---
        
        // Touch/Mouse Controls (Fallback for no sensors)
        function setupTouchControls() {
            const el = document.getElementById('viewport');
            
            // Mouse
            el.addEventListener('mousedown', e => { state.drag.active = true; state.drag.startX = e.clientX; state.drag.startY = e.clientY; });
            window.addEventListener('mouseup', () => state.drag.active = false);
            window.addEventListener('mousemove', e => {
                if(state.drag.active) {
                    const dx = e.clientX - state.drag.startX;
                    const dy = e.clientY - state.drag.startY;
                    state.manualOffset.x += dx * 0.005;
                    state.manualOffset.y += dy * 0.005;
                    state.drag.startX = e.clientX;
                    state.drag.startY = e.clientY;
                }
            });

            // Touch
            el.addEventListener('touchstart', e => { state.drag.active = true; state.drag.startX = e.touches[0].clientX; state.drag.startY = e.touches[0].clientY; });
            el.addEventListener('touchend', () => state.drag.active = false);
            el.addEventListener('touchmove', e => {
                if(state.drag.active) {
                    const dx = e.touches[0].clientX - state.drag.startX;
                    const dy = e.touches[0].clientY - state.drag.startY;
                    state.manualOffset.x += dx * 0.005;
                    state.manualOffset.y += dy * 0.005;
                    state.drag.startX = e.touches[0].clientX;
                    state.drag.startY = e.touches[0].clientY;
                }
            });
        }

        // Sensors
        const finalQ = new THREE.Quaternion();
        const deviceEuler = new THREE.Euler();
        const screenQ = new THREE.Quaternion();
        const worldQ = new THREE.Quaternion(-Math.sqrt(0.5), 0, 0, Math.sqrt(0.5)); // -90 X

        function handleOrientation(event) {
            if(!event.alpha) return;
            const alpha = THREE.MathUtils.degToRad(event.alpha);
            const beta = THREE.MathUtils.degToRad(event.beta);
            const gamma = THREE.MathUtils.degToRad(event.gamma);
            const orient = (window.orientation || 0) * THREE.MathUtils.DEG2RAD;

            deviceEuler.set(beta, alpha, -gamma, 'YXZ');
            finalQ.setFromEuler(deviceEuler);
            finalQ.multiply(worldQ);
            
            const minusHalfAngle = -orient / 2;
            screenQ.set(0, 0, Math.sin(minusHalfAngle), Math.cos(minusHalfAngle));
            finalQ.multiply(screenQ);

            // Update Compass UI
            const deg = event.alpha;
            document.getElementById('compass-ui').style.transform = `rotate(${deg}deg)`;
            
            // Override manual if sensor exists
            state.drag.active = false; 
        }

        // Search
        const searchInput = document.getElementById('search');
        const resultsDiv = document.getElementById('results');

        searchInput.addEventListener('input', (e) => {
            const val = e.target.value.toLowerCase();
            resultsDiv.innerHTML = '';
            if(val.length < 2) { resultsDiv.style.display='none'; return; }
            
            const hits = celestialDB.filter(i => i.name.toLowerCase().includes(val));
            if(hits.length>0) {
                resultsDiv.style.display='block';
                hits.slice(0,5).forEach(hit => {
                    const div = document.createElement('div');
                    div.className = 'item';
                    div.innerHTML = `<span>${hit.name}</span><span class="type">${hit.type}</span>`;
                    div.onclick = () => {
                        state.target = hit;
                        searchInput.value = hit.name;
                        resultsDiv.style.display='none';
                        document.getElementById('reticle').classList.add('active');
                    };
                    resultsDiv.appendChild(div);
                });
            } else { resultsDiv.style.display='none'; }
        });

        // Loop
        function animate() {
            requestAnimationFrame(animate);

            if (state.drag.active || (state.manualOffset.x !== 0 && !window.DeviceOrientationEvent?.requestPermission)) {
                // Use manual look if dragging or no sensors
                // Simple Euler rotation for desktop testing
                camera.rotation.order = 'YXZ';
                camera.rotation.y = state.manualOffset.x;
                camera.rotation.x = state.manualOffset.y;
            } else {
                // Use Sensor Quaternion
                camera.quaternion.slerp(finalQ, 0.1); // Smooth
            }

            // Target Guide
            if(state.target) {
                const targetWorld = state.target.pos.clone();
                targetWorld.applyEuler(state.target.group.rotation); // Apply Sky rotation
                targetWorld.applyEuler(worldGroup.rotation); // Apply Lat rotation
                
                targetWorld.project(camera);
                
                const x = (targetWorld.x * .5 + .5) * window.innerWidth;
                const y = -(targetWorld.y * .5 - .5) * window.innerHeight;
                
                const reticle = document.getElementById('reticle');
                const arrow = document.getElementById('arrow-guide');
                
                if(targetWorld.z < 1) { // In front
                    if(x>0 && x<window.innerWidth && y>0 && y<window.innerHeight) {
                        reticle.style.display = 'block';
                        reticle.style.transform = `translate(-50%, -50%) translate(${x}px, ${y}px)`;
                        arrow.style.display = 'none';
                    } else {
                        arrow.style.display = 'block';
                        reticle.style.display = 'none';
                        moveArrow(x, y);
                    }
                } else {
                    arrow.style.display = 'block';
                    reticle.style.display = 'none';
                    moveArrow(x, y, true);
                }
            }

            renderer.render(scene, camera);
        }

        function moveArrow(tx, ty, behind=false) {
            const cx = window.innerWidth/2;
            const cy = window.innerHeight/2;
            let dx = tx - cx;
            let dy = ty - cy;
            if(behind) { dx = -dx; dy = -dy; }
            const ang = Math.atan2(dy, dx);
            const r = Math.min(cx, cy) - 50;
            const fx = cx + Math.cos(ang)*r;
            const fy = cy + Math.sin(ang)*r;
            document.getElementById('arrow-guide').style.transform = `translate(${fx}px, ${fy}px) rotate(${ang + Math.PI/2}rad)`;
        }

    </script>
</body>
</html>
