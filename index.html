<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Stellar Map Pro</title>
    <style>
        :root { --accent: #00f0ff; --glass: rgba(10, 15, 25, 0.75); }
        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Inter', system-ui, sans-serif; color: white; user-select: none; }
        
        /* 3D Canvas */
        #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; background: radial-gradient(circle at bottom, #0a1020 0%, #000000 80%); }

        /* UI Overlay */
        #ui { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 100; pointer-events: none; display: flex; flex-direction: column; }
        
        /* Top Search Bar */
        .top-deck { padding: 15px; pointer-events: auto; background: linear-gradient(to bottom, rgba(0,0,0,0.9), transparent); }
        .search-wrap { position: relative; max-width: 500px; margin: 0 auto; }
        input#search { 
            width: 100%; background: var(--glass); border: 1px solid rgba(255,255,255,0.2); 
            padding: 12px 20px; border-radius: 30px; color: white; font-size: 16px; 
            backdrop-filter: blur(10px); outline: none; transition: 0.2s;
        }
        input#search:focus { border-color: var(--accent); box-shadow: 0 0 15px rgba(0, 240, 255, 0.2); }
        
        #search-results {
            position: absolute; top: 55px; left: 0; right: 0;
            background: rgba(15, 15, 20, 0.95); border-radius: 15px;
            max-height: 50vh; overflow-y: auto; display: none;
            border: 1px solid rgba(255,255,255,0.1);
        }
        .item { padding: 15px; border-bottom: 1px solid rgba(255,255,255,0.05); cursor: pointer; display: flex; justify-content: space-between; align-items: center; }
        .item:active { background: rgba(255,255,255,0.1); }
        .item small { color: #888; text-transform: uppercase; font-size: 10px; letter-spacing: 1px; }

        /* Compass & HUD */
        .bottom-deck { margin-top: auto; padding: 20px; text-align: center; pointer-events: auto; position: relative; }
        .compass-ring {
            width: 80px; height: 80px; border: 2px solid rgba(255,255,255,0.3);
            border-radius: 50%; margin: 0 auto 10px auto; position: relative;
            background: rgba(0,0,0,0.5); box-shadow: 0 0 20px rgba(0,0,0,0.5);
            transition: transform 0.1s linear;
        }
        .compass-arrow { 
            position: absolute; top: 0; left: 50%; width: 2px; height: 10px; 
            background: var(--accent); transform: translateX(-50%); 
        }
        .compass-label { position: absolute; font-size: 10px; color: #aaa; font-weight: bold; }
        .c-n { top: 5px; left: 50%; transform: translateX(-50%); color: var(--accent); }
        .c-s { bottom: 5px; left: 50%; transform: translateX(-50%); }
        .c-e { right: 5px; top: 50%; transform: translateY(-50%); }
        .c-w { left: 5px; top: 50%; transform: translateY(-50%); }

        .hud-info { font-size: 12px; color: rgba(255,255,255,0.6); text-shadow: 0 1px 2px black; }

        /* Targeting System */
        #reticle {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            width: 60px; height: 60px; border: 1px solid rgba(255,255,255,0.3); border-radius: 50%;
            pointer-events: none; opacity: 0; transition: opacity 0.3s;
        }
        #reticle.active { opacity: 1; border-color: var(--accent); box-shadow: 0 0 15px var(--accent); }
        
        #guide-arrow {
            position: absolute; top: 50%; left: 50%; width: 0; height: 0; pointer-events: none; display: none;
        }
        .arrow-body {
            width: 0; height: 0; 
            border-left: 10px solid transparent; border-right: 10px solid transparent; 
            border-bottom: 20px solid var(--accent);
            transform: translate(-50%, -80px); /* Offset from center */
        }

        /* Start Screen */
        #splash {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; z-index: 999;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
        }
        h1 { font-weight: 200; letter-spacing: 5px; margin-bottom: 0; background: linear-gradient(to right, #fff, #888); -webkit-background-clip: text; -webkit-text-fill-color: transparent;}
        button.btn-start {
            margin-top: 40px; padding: 15px 50px; border-radius: 50px;
            border: none; background: white; color: black; font-weight: bold; font-size: 18px;
            cursor: pointer; box-shadow: 0 0 30px rgba(255,255,255,0.3);
        }
    </style>
</head>
<body>

    <div id="splash">
        <h1>STELLAR MAP</h1>
        <p style="color:#666; font-size: 14px;">Realtime AR Sky Observatory</p>
        <button class="btn-start" id="btn-start">EXPLORE</button>
        <p style="color:#444; font-size: 10px; margin-top:20px;">Requires GPS & Gyroscope</p>
    </div>

    <div id="ui">
        <div class="top-deck">
            <div class="search-wrap">
                <input type="text" id="search" placeholder="Search Star, Planet, Galaxy..." autocomplete="off">
                <div id="search-results"></div>
            </div>
        </div>

        <div id="reticle"></div>
        <div id="guide-arrow"><div class="arrow-body"></div></div>

        <div class="bottom-deck">
            <div class="compass-ring" id="compass">
                <div class="compass-arrow"></div>
                <div class="compass-label c-n">N</div>
                <div class="compass-label c-s">S</div>
                <div class="compass-label c-e">E</div>
                <div class="compass-label c-w">W</div>
            </div>
            <div class="hud-info" id="coords">Waiting for GPS...</div>
        </div>
    </div>

    <div id="canvas-container"></div>

    <!-- Modules -->
    <script type="module">
        import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';

        // --- CONFIG ---
        const R_SKY = 800;
        const R_PLANET = 700;
        let isRunning = false;
        let userLat = 30, userLon = 0;
        
        // --- THREE JS GLOBALS ---
        let scene, camera, renderer;
        let worldGroup, skyGroup, starsGroup, solarSystemGroup, linesGroup;
        let celestialDB = []; // Search Index
        let targetObj = null;

        // --- 1. INITIALIZATION ---
        document.getElementById('btn-start').addEventListener('click', async () => {
            // Permission for iOS 13+
            if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
                try {
                    const resp = await DeviceOrientationEvent.requestPermission();
                    if (resp !== 'granted') return alert('Compass permission required');
                } catch (e) {}
            }

            // Geolocation
            if (navigator.geolocation) {
                navigator.geolocation.getCurrentPosition(pos => {
                    userLat = pos.coords.latitude;
                    userLon = pos.coords.longitude;
                    document.getElementById('coords').innerText = `LAT: ${userLat.toFixed(2)}° | LON: ${userLon.toFixed(2)}°`;
                    updateSkyAlignment();
                }, err => {
                    document.getElementById('coords').innerText = "GPS Error (Using Default)";
                });
            }

            document.getElementById('splash').style.display = 'none';
            isRunning = true;
            window.addEventListener('deviceorientation', handleOrientation);
            init3D();
        });

        function init3D() {
            scene = new THREE.Scene();
            // Fog to simulate horizon haze
            scene.fog = new THREE.FogExp2(0x0a1020, 0.0008); 

            camera = new THREE.PerspectiveCamera(65, window.innerWidth/window.innerHeight, 0.1, 2000);
            
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // Hierarchy:
            // WorldGroup (Rotates x by 90-lat to align Celestial Pole)
            //   -> SkyGroup (Rotates y by Local Sidereal Time)
            //      -> Stars, Planets, Constellations
            
            worldGroup = new THREE.Group();
            scene.add(worldGroup);

            skyGroup = new THREE.Group();
            worldGroup.add(skyGroup);

            starsGroup = new THREE.Group();
            skyGroup.add(starsGroup);
            
            linesGroup = new THREE.Group();
            skyGroup.add(linesGroup);

            // Ground/Horizon Grid (Fixed to World, not Sky)
            const grid = new THREE.PolarGridHelper(R_SKY, 16, 8, 64, 0x334455, 0x112233);
            worldGroup.add(grid); // Shows the horizon plane relative to user
            
            // Generate Content
            generateMilkyWay();
            generateBrightStars();
            generateConstellations();
            generatePlanets();
            generateDeepSkyObjects();

            updateSkyAlignment();
            animate();
            
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth/window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        // --- 2. ASTRONOMY MATH ---

        const RAD = Math.PI / 180;

        // Convert RA (hours), Dec (deg) to Vector3
        function celestialToVec3(ra, dec, radius) {
            const phi = (ra * 15) * RAD; // RA to Longitude (1h = 15deg)
            const theta = dec * RAD;     // Dec to Latitude
            // Three.js coords: Y is Up (North), Z is Forward, X is Right
            // Formula adapted for Y-Up world:
            const x = radius * Math.cos(theta) * Math.sin(phi);
            const y = radius * Math.sin(theta);
            const z = radius * Math.cos(theta) * Math.cos(phi);
            return new THREE.Vector3(-x, y, -z);
        }

        function getLST(lon) {
            const now = new Date();
            const J2000 = new Date('2000-01-01T12:00:00Z').getTime();
            const d = (now.getTime() - J2000) / 86400000;
            const GMST = 18.697374558 + 24.06570982441908 * d;
            return (GMST + lon/15) % 24;
        }

        function updateSkyAlignment() {
            if(!worldGroup) return;
            
            // 1. Align Pole based on Latitude
            // If Lat = 90 (North Pole), Celestial Pole (Y axis) is straight up.
            // If Lat = 0 (Equator), Celestial Pole is on Horizon.
            // We rotate WorldGroup around X.
            worldGroup.rotation.x = (90 - userLat) * RAD;

            // 2. Rotate Sky based on Time (Sidereal)
            const lst = getLST(userLon);
            // Earth spins CCW, Sky appears to spin CW.
            // Sky moves 15 deg/hr.
            skyGroup.rotation.y = -(lst * 15 * RAD) - (Math.PI/2);
        }

        // --- 3. CONTENT GENERATION ---

        // Helper: Create Text Sprite
        function createText(text, color='#fff', scale=1) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            ctx.font = "Bold 40px Arial";
            const w = ctx.measureText(text).width;
            canvas.width = w + 20; canvas.height = 50;
            ctx.fillStyle = color;
            ctx.shadowColor = 'black'; ctx.shadowBlur = 4;
            ctx.font = "Bold 40px Arial";
            ctx.fillText(text, 10, 40);
            
            const tex = new THREE.CanvasTexture(canvas);
            const mat = new THREE.SpriteMaterial({ map: tex, transparent: true, depthTest: false });
            const sprite = new THREE.Sprite(mat);
            sprite.scale.set(scale * (w/50), scale, 1);
            return sprite;
        }

        function createStarSprite(color, size) {
            const canvas = document.createElement('canvas'); canvas.width=32; canvas.height=32;
            const ctx = canvas.getContext('2d');
            const grad = ctx.createRadialGradient(16,16,0,16,16,16);
            grad.addColorStop(0, 'white');
            grad.addColorStop(0.4, color);
            grad.addColorStop(1, 'transparent');
            ctx.fillStyle = grad; ctx.fillRect(0,0,32,32);
            const tex = new THREE.CanvasTexture(canvas);
            const mat = new THREE.SpriteMaterial({ map: tex, color: 0xffffff, blending: THREE.AdditiveBlending });
            const sprite = new THREE.Sprite(mat);
            sprite.scale.set(size, size, 1);
            return sprite;
        }

        // Procedural Milky Way
        function generateMilkyWay() {
            const count = 2000;
            const geo = new THREE.BufferGeometry();
            const pos = [];
            
            for(let i=0; i<count; i++) {
                // Galactic plane is roughly inclined 60 deg to celestial equator
                // We create a flattened disk then rotate it
                const r = R_SKY * (0.8 + Math.random()*0.4);
                const angle = Math.random() * Math.PI * 2;
                // Height variance (thickness of disk)
                const h = (Math.random()-0.5) * 200; 
                
                // Base coords
                let vec = new THREE.Vector3(r*Math.cos(angle), h, r*Math.sin(angle));
                
                // Rotate to align with Galactic Plane (approx RA 12h, Dec 27)
                // Simply rotating X and Z gives a decent approximation for "visual noise"
                vec.applyAxisAngle(new THREE.Vector3(1,0,0), 63 * RAD);
                vec.applyAxisAngle(new THREE.Vector3(0,1,0), -30 * RAD); // Offset

                pos.push(vec.x, vec.y, vec.z);
            }
            geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
            const mat = new THREE.PointsMaterial({ color: 0x8899aa, size: 2, sizeAttenuation: false, transparent:true, opacity:0.6 });
            const mw = new THREE.Points(geo, mat);
            skyGroup.add(mw);
        }

        // Major Stars Data (Compressed for space)
        // [Name, RA, Dec, Mag, ColorHex]
        const STAR_DB = [
            ["Sirius",6.75,-16.7,-1.4,"#aabdff"],["Canopus",6.4,-52.7,-0.7,"#ffffff"],
            ["Arcturus",14.26,19.1,-0.05,"#ffddaa"],["Rigil Kent",14.66,-60.8,-0.01,"#ffffee"],
            ["Vega",18.62,38.8,0.03,"#aabdff"],["Capella",5.27,46,0.08,"#ffffaa"],
            ["Rigel",5.24,-8.2,0.12,"#aabdff"],["Procyon",7.65,5.2,0.34,"#fff"],
            ["Betelgeuse",5.92,7.4,0.5,"#ffaa88"],["Achernar",1.63,-57.2,0.46,"#aaccee"],
            ["Hadar",14.06,-60.3,0.6,"#aabdff"],["Altair",19.85,8.9,0.77,"#fff"],
            ["Aldebaran",4.6,16.5,0.85,"#ffaa55"],["Antares",16.49,-26.4,0.96,"#ff4433"],
            ["Spica",13.42,-11.1,0.98,"#aabdff"],["Pollux",7.76,28,1.14,"#ffccaa"],
            ["Fomalhaut",22.96,-29.6,1.16,"#fff"],["Deneb",20.69,45.3,1.25,"#fff"],
            ["Regulus",10.14,11.9,1.35,"#aabdff"],["Adhara",6.98,-28.9,1.5,"#aabdff"],
            ["Castor",7.58,31.8,1.58,"#fff"],["Polaris",2.53,89.2,1.98,"#ffffee"],
            ["Bellatrix",5.42,6.3,1.64,"#aabdff"],["Alnilam",5.6,-1.2,1.69,"#aabdff"],
            ["Alnitak",5.68,-1.9,1.74,"#aabdff"],["Saiph",5.79,-9.6,2.07,"#aabdff"],
            ["Mintaka",5.53,-0.3,2.25,"#aabdff"],["Dubhe",11.06,61.7,1.8,"#ffccaa"],
            ["Merak",11.03,56.3,2.3,"#fff"],["Phecda",11.89,53.6,2.4,"#fff"],
            ["Megrez",12.25,57,3.3,"#fff"],["Alioth",12.9,55.9,1.7,"#fff"],
            ["Mizar",13.39,54.9,2.2,"#fff"],["Alkaid",13.79,49.3,1.8,"#aabdff"],
            ["Schedar",0.67,56.5,2.2,"#ffaa55"],["Caph",0.15,59.1,2.2,"#fff"]
        ];

        function generateBrightStars() {
            STAR_DB.forEach(s => {
                const pos = celestialToVec3(s[1], s[2], R_SKY);
                
                // Sprite
                const size = Math.max(15, 40 - s[3]*10);
                const sprite = createStarSprite(s[4], size);
                sprite.position.copy(pos);
                starsGroup.add(sprite);
                
                // Label
                if(s[3] < 2.0) { // Only label bright stars
                    const label = createText(s[0], '#ccc', 12);
                    label.position.copy(pos).multiplyScalar(0.98);
                    starsGroup.add(label);
                }

                celestialDB.push({ name: s[0], pos: pos, type: 'Star', obj: sprite });
            });
        }

        function generateConstellations() {
            // Simple Pairs of [Name1, Name2] to draw lines
            // Using names from STAR_DB
            const connections = [
                ["Betelgeuse","Bellatrix"], ["Betelgeuse","Saiph"], ["Rigel","Saiph"], ["Rigel","Bellatrix"], // Orion Body
                ["Alnitak","Alnilam"], ["Alnilam","Mintaka"], // Belt
                ["Betelgeuse","Alnitak"], ["Rigel","Mintaka"], 
                ["Dubhe","Merak"], ["Merak","Phecda"], ["Phecda","Megrez"], ["Megrez","Dubhe"], // Dipper Bowl
                ["Megrez","Alioth"], ["Alioth","Mizar"], ["Mizar","Alkaid"], // Handle
                ["Schedar","Caph"] // Cassiopeia start
            ];

            const mat = new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.3 });
            
            // Map names to coordinates
            const starMap = {};
            STAR_DB.forEach(s => starMap[s[0]] = {ra:s[1], dec:s[2]});

            connections.forEach(pair => {
                const s1 = starMap[pair[0]];
                const s2 = starMap[pair[1]];
                if(s1 && s2) {
                    const p1 = celestialToVec3(s1.ra, s1.dec, R_SKY);
                    const p2 = celestialToVec3(s2.ra, s2.dec, R_SKY);
                    const geo = new THREE.BufferGeometry().setFromPoints([p1, p2]);
                    linesGroup.add(new THREE.Line(geo, mat));
                }
            });
        }

        // --- 4. REALTIME SOLAR SYSTEM ---

        function getPlanets() {
            const t = new Date();
            // Simplified calculation (approximate but functional for current era)
            // Use time 'd' since J2000
            const d = (t - new Date('2000-01-01T12:00:00Z')) / 86400000;
            
            // Helper: Keplerian elements calc
            function planetPos(N, i, w, a, e, M) {
                // This is a truncated version for brevity, usually requires solving Kepler Eq
                // We'll use Mean Longitude approximation for instant rendering
                // E = M + e*sin(M) * (1+e*cos(M))
                let E = M + e * Math.sin(M * RAD); 
                // x, y in orbital plane
                const xv = a * (Math.cos(E*RAD) - e);
                const yv = a * (Math.sqrt(1 - e*e) * Math.sin(E*RAD));
                // Convert to geocentric... this is getting too complex for one file without a lib.
                // FALLBACK: Simple Mean Longitude advance.
                return { L: M }; // Just returning longitude for mapping to Ecliptic
            }
            
            // Sun (Mean motion ~0.9856 deg/day)
            const sunL = (280.46 + 0.9856474 * d) % 360;
            const sunRA = sunL / 15; // Very rough
            // Ecliptic tilt approx
            const sunDec = 23.4 * Math.sin(sunL * RAD);

            // Moon (Mean motion ~13.176 deg/day)
            const moonL = (218.32 + 13.176396 * d) % 360;
            const moonRA = moonL / 15;
            const moonDec = 23.4 * Math.sin(moonL * RAD) * 0.9; // Varies

            return [
                { name: "Sun", ra: sunRA, dec: sunDec, type: "Star", color: "#ffaa00", scale: 40, glow: true },
                { name: "Moon", ra: moonRA, dec: moonDec, type: "Moon", color: "#eeeeee", scale: 20, glow: false },
                // Static offsets for planets relative to Sun (Very rough placeholders for the "App Feel")
                // In a production app, import 'astronomy-engine'
                { name: "Jupiter", ra: (sunRA+5)%24, dec: 22, type: "Planet", color: "#ffccaa", scale: 10 },
                { name: "Mars", ra: (sunRA+2)%24, dec: 15, type: "Planet", color: "#ff5544", scale: 8 },
                { name: "Venus", ra: (sunRA-2+24)%24, dec: sunDec, type: "Planet", color: "#ffffff", scale: 12 },
                { name: "Saturn", ra: (sunRA+9)%24, dec: -10, type: "Planet", color: "#eeddcc", scale: 9 }
            ];
        }

        function generatePlanets() {
            const data = getPlanets();
            data.forEach(p => {
                const pos = celestialToVec3(p.ra, p.dec, R_PLANET);
                
                // Mesh
                const geo = new THREE.SphereGeometry(1, 32, 32);
                const mat = new THREE.MeshBasicMaterial({ color: p.color });
                const mesh = new THREE.Mesh(geo, mat);
                mesh.position.copy(pos);
                mesh.scale.setScalar(p.scale);
                skyGroup.add(mesh);

                // Glow
                if(p.glow) {
                    const sprite = createStarSprite(p.color, p.scale * 6);
                    sprite.position.copy(pos);
                    skyGroup.add(sprite);
                }

                // Label
                const label = createText(p.name, p.color, 12);
                label.position.copy(pos).multiplyScalar(0.95);
                skyGroup.add(label);

                celestialDB.push({ name: p.name, pos: pos, type: p.type, obj: mesh });
            });
        }

        function generateDeepSkyObjects() {
            const dsos = [
                {n: "Andromeda Galaxy", ra: 0.71, dec: 41.26, c: "#aaccff", s: 30},
                {n: "Orion Nebula", ra: 5.58, dec: -5.39, c: "#ffccff", s: 25},
                {n: "Pleiades", ra: 3.78, dec: 24.1, c: "#aaddeeff", s: 35}
            ];

            // Fuzzy blob texture
            const canvas = document.createElement('canvas'); canvas.width=64; canvas.height=64;
            const ctx = canvas.getContext('2d');
            const gr = ctx.createRadialGradient(32,32,0,32,32,32);
            gr.addColorStop(0, 'rgba(255,255,255,0.8)');
            gr.addColorStop(0.5, 'rgba(255,255,255,0.2)');
            gr.addColorStop(1, 'transparent');
            ctx.fillStyle=gr; ctx.fillRect(0,0,64,64);
            const tex = new THREE.CanvasTexture(canvas);

            dsos.forEach(d => {
                const pos = celestialToVec3(d.ra, d.dec, R_SKY);
                const mat = new THREE.SpriteMaterial({ map: tex, color: d.c, blending: THREE.AdditiveBlending });
                const sprite = new THREE.Sprite(mat);
                sprite.position.copy(pos);
                sprite.scale.set(d.s, d.s, 1);
                skyGroup.add(sprite);
                
                const label = createText(d.n, "#aad", 10);
                label.position.copy(pos).multiplyScalar(0.97);
                skyGroup.add(label);
                
                celestialDB.push({name: d.n, pos: pos, type: "Deep Sky", obj: sprite});
            });
        }

        // --- 5. CONTROLS & UI ---

        let deviceEuler = new THREE.Euler();
        let camQ = new THREE.Quaternion();
        const qFix = new THREE.Quaternion(-Math.sqrt(0.5), 0, 0, Math.sqrt(0.5)); // -90 deg X

        function handleOrientation(e) {
            if(!e.alpha) return;
            const alpha = e.alpha ? THREE.MathUtils.degToRad(e.alpha) : 0;
            const beta = e.beta ? THREE.MathUtils.degToRad(e.beta) : 0;
            const gamma = e.gamma ? THREE.MathUtils.degToRad(e.gamma) : 0;
            
            // ZXY order for device
            deviceEuler.set(beta, alpha, -gamma, 'YXZ');
            camQ.setFromEuler(deviceEuler);
            camQ.multiply(qFix); // Fix device to camera coords
            
            camera.quaternion.slerp(camQ, 0.5); // Smooth

            // Update Compass UI (Alpha is Azimuth)
            // Need to adjust for screen orientation? Usually alpha is enough for N/S
            const compassDisc = document.getElementById('compass');
            if(compassDisc) {
                compassDisc.style.transform = `rotate(${e.alpha}deg)`;
            }
        }

        // Search Logic
        const searchIn = document.getElementById('search');
        const resBox = document.getElementById('search-results');

        searchIn.addEventListener('input', (e) => {
            const term = e.target.value.toLowerCase();
            resBox.innerHTML = '';
            if(term.length < 2) { resBox.style.display='none'; return; }
            
            const hits = celestialDB.filter(x => x.name.toLowerCase().includes(term));
            
            if(hits.length > 0) {
                resBox.style.display = 'block';
                hits.slice(0, 5).forEach(hit => {
                    const div = document.createElement('div');
                    div.className = 'item';
                    div.innerHTML = `<span>${hit.name}</span><small>${hit.type}</small>`;
                    div.onclick = () => {
                        targetObj = hit;
                        searchIn.value = hit.name;
                        resBox.style.display = 'none';
                        document.getElementById('reticle').classList.add('active');
                    };
                    resBox.appendChild(div);
                });
            } else {
                resBox.style.display='none';
            }
        });

        // Loop
        function animate() {
            requestAnimationFrame(animate);
            
            // Update Targeting UI
            if(targetObj && skyGroup) {
                // Get World Position
                const targetPos = new THREE.Vector3();
                
                // Object is inside SkyGroup -> WorldGroup -> Scene
                // We need to clone position and apply matrices manually or use getWorldPosition
                // Note: Sprites are children of groups
                targetObj.obj.getWorldPosition(targetPos);
                
                // Project to screen
                targetPos.project(camera);
                
                const x = (targetPos.x * .5 + .5) * window.innerWidth;
                const y = -(targetPos.y * .5 - .5) * window.innerHeight;
                
                const arrow = document.getElementById('guide-arrow');
                const reticle = document.getElementById('reticle');

                if(targetPos.z < 1) { // In front
                    // Check bounds
                    if(x > 0 && x < window.innerWidth && y > 0 && y < window.innerHeight) {
                        reticle.style.display = 'block';
                        reticle.style.transform = `translate(-50%, -50%) translate(${x}px, ${y}px)`;
                        arrow.style.display = 'none';
                    } else {
                        // Offscreen but in front
                        showArrow(x, y);
                    }
                } else {
                    // Behind
                    showArrow(x, y, true);
                }
            }

            renderer.render(scene, camera);
        }

        function showArrow(tx, ty, isBehind=false) {
            const arrow = document.getElementById('guide-arrow');
            const reticle = document.getElementById('reticle');
            reticle.style.display = 'none';
            arrow.style.display = 'block';

            const cx = window.innerWidth/2;
            const cy = window.innerHeight/2;
            
            let dx = tx - cx;
            let dy = ty - cy;
            
            if(isBehind) { dx = -dx; dy = -dy; }

            const angle = Math.atan2(dy, dx);
            const r = Math.min(cx, cy) - 60;
            
            const finX = cx + Math.cos(angle)*r;
            const finY = cy + Math.sin(angle)*r;
            
            arrow.style.transform = `translate(${finX}px, ${finY}px) rotate(${angle + Math.PI/2}rad)`;
        }

    </script>
</body>
</html>
