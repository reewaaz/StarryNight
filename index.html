<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>Pocket Planetarium 3D</title>
    <style>
        :root {
            --primary: #00f0ff;
            --bg-overlay: rgba(10, 15, 30, 0.85);
        }
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Segoe UI', sans-serif; color: white; }
        canvas { display: block; }
        
        /* UI Overlay Layer */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; /* Let touches pass to canvas */
            display: flex; flex-direction: column; justify-content: space-between;
        }

        /* Top HUD */
        .hud-top {
            padding: 15px;
            background: linear-gradient(to bottom, rgba(0,0,0,0.9), transparent);
            pointer-events: auto;
            display: flex; gap: 10px; align-items: center;
        }
        
        #search-container {
            position: relative; flex-grow: 1;
        }
        
        input#search-input {
            width: 100%;
            background: rgba(255,255,255,0.1);
            border: 1px solid var(--primary);
            color: white; padding: 10px; border-radius: 20px;
            font-size: 16px; outline: none;
            backdrop-filter: blur(5px);
        }
        
        #search-results {
            position: absolute; top: 100%; left: 0; right: 0;
            background: var(--bg-overlay);
            border: 1px solid #333;
            max-height: 200px; overflow-y: auto;
            display: none;
        }
        
        .result-item {
            padding: 10px; border-bottom: 1px solid #333; cursor: pointer;
        }
        .result-item:hover { background: var(--primary); color: black; }

        /* Reticle & Center Info */
        #center-reticle {
            position: absolute; top: 50%; left: 50%;
            width: 20px; height: 20px;
            border: 2px solid rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 5;
        }

        #info-panel {
            position: absolute; top: 55%; left: 50%;
            transform: translate(-50%, 0);
            text-align: center;
            text-shadow: 0 2px 4px black;
            opacity: 0; transition: opacity 0.3s;
        }
        #info-name { font-size: 1.5rem; font-weight: bold; color: var(--primary); }
        #info-coords { font-size: 0.9rem; color: #ccc; }

        /* Bottom Controls */
        .hud-bottom {
            padding: 20px;
            background: linear-gradient(to top, rgba(0,0,0,0.9), transparent);
            text-align: center; font-size: 0.8rem; color: #888;
        }
        
        #loading {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; display: flex; align-items: center; justify-content: center;
            z-index: 999; flex-direction: column;
        }
        .spinner {
            width: 40px; height: 40px; border: 4px solid #333; border-top: 4px solid var(--primary);
            border-radius: 50%; animation: spin 1s linear infinite; margin-bottom: 10px;
        }
        @keyframes spin { 100% { transform: rotate(360deg); } }
        
        #guidance-arrow {
            position: absolute; top: 50%; left: 50%;
            width: 0; height: 0; 
            border-left: 15px solid transparent;
            border-right: 15px solid transparent;
            border-bottom: 30px solid var(--primary);
            transform-origin: 50% 150%; /* Pivot around reticle */
            display: none;
        }
    </style>
    <!-- Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/astronomy-engine@2.1.19/astronomy.browser.min.js"></script>
</head>
<body>

    <!-- Loading Screen -->
    <div id="loading">
        <div class="spinner"></div>
        <div id="loading-text">Acquiring GPS...</div>
    </div>

    <!-- UI Overlay -->
    <div id="ui-layer">
        <div class="hud-top">
            <div id="search-container">
                <input type="text" id="search-input" placeholder="Search Star, Planet..." autocomplete="off">
                <div id="search-results"></div>
            </div>
        </div>

        <div id="center-reticle"></div>
        <div id="guidance-arrow"></div>

        <div id="info-panel">
            <div id="info-name">Object Name</div>
            <div id="info-coords">Az: 0° Alt: 0°</div>
        </div>

        <div class="hud-bottom">
            <span>Drag to look • Pinch to zoom</span>
        </div>
    </div>

    <script>
        /**
         * APPLICATION STATE
         */
        const AppState = {
            lat: 0,
            lon: 0,
            time: new Date(),
            objects: [], // Stores { name, type, mesh, ra, dec }
            targetObject: null,
            isUserInteracting: false,
            lonStart: 0, latStart: 0,
            phi: 0, theta: 0
        };

        // DOM Elements
        const elLoading = document.getElementById('loading');
        const elLoadingText = document.getElementById('loading-text');
        const elInfo = document.getElementById('info-panel');
        const elInfoName = document.getElementById('info-name');
        const elInfoCoords = document.getElementById('info-coords');
        const elSearchInput = document.getElementById('search-input');
        const elSearchResults = document.getElementById('search-results');
        const elArrow = document.getElementById('guidance-arrow');

        /**
         * THREE.JS SETUP
         */
        const scene = new THREE.Scene();
        // Fog to fade out near horizon
        scene.fog = new THREE.FogExp2(0x000000, 0.001);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        // Raycaster for object picking
        const raycaster = new THREE.Raycaster();
        const centerPoint = new THREE.Vector2(0, 0); // Center of screen

        /**
         * TEXTURE GENERATION (Procedural to avoid external assets)
         */
        function createCircleTexture(color, blur = 0.5) {
            const canvas = document.createElement('canvas');
            canvas.width = 64; canvas.height = 64;
            const ctx = canvas.getContext('2d');
            const grad = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
            grad.addColorStop(0, color);
            grad.addColorStop(blur, color); // solid center
            grad.addColorStop(1, 'transparent');
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, 64, 64);
            const tex = new THREE.CanvasTexture(canvas);
            return tex;
        }

        const texStar = createCircleTexture('#ffffff', 0.2);
        const texPlanet = createCircleTexture('#ffffff', 0.8);
        const texSun = createCircleTexture('#ffaa00', 0.4);

        /**
         * DATA CATALOGS
         */
        // Simple catalog of bright stars (RA/Dec in Degrees for simplicity of conversion later, or Hours/Deg)
        // Here we use Right Ascension (Hours) and Declination (Degrees) J2000
        const BRIGHT_STARS = [
            { name: "Sirius", ra: 6.75, dec: -16.71, mag: -1.46, color: 0xabdeff },
            { name: "Canopus", ra: 6.39, dec: -52.69, mag: -0.74, color: 0xf0f0f0 },
            { name: "Arcturus", ra: 14.26, dec: 19.18, mag: -0.05, color: 0xffddaa },
            { name: "Rigel Centaurus", ra: 14.66, dec: -60.83, mag: -0.01, color: 0xfff5cc },
            { name: "Vega", ra: 18.61, dec: 38.78, mag: 0.03, color: 0xabdeff },
            { name: "Rigel", ra: 5.24, dec: -8.2, mag: 0.13, color: 0xccddee },
            { name: "Procyon", ra: 7.65, dec: 5.22, mag: 0.34, color: 0xffffee },
            { name: "Betelgeuse", ra: 5.91, dec: 7.4, mag: 0.5, color: 0xffaa88 },
            { name: "Altair", ra: 19.84, dec: 8.87, mag: 0.77, color: 0xffffff },
            { name: "Aldebaran", ra: 4.59, dec: 16.5, mag: 0.87, color: 0xffaa55 },
            { name: "Antares", ra: 16.49, dec: -26.43, mag: 0.96, color: 0xff4433 },
            { name: "Spica", ra: 13.41, dec: -11.16, mag: 0.98, color: 0xaaddff },
            { name: "Pollux", ra: 7.75, dec: 28.02, mag: 1.14, color: 0xffdbb8 },
            { name: "Fomalhaut", ra: 22.96, dec: -29.62, mag: 1.16, color: 0xffffff },
            { name: "Deneb", ra: 20.69, dec: 45.28, mag: 1.25, color: 0xffffff },
            { name: "Regulus", ra: 10.13, dec: 11.96, mag: 1.36, color: 0xaabbee },
            { name: "Polaris", ra: 2.53, dec: 89.26, mag: 1.98, color: 0xffffee }, // North Star
            // Major Constellation stars for lines
            // Orion
            { name: "Bellatrix", ra: 5.41, dec: 6.34, mag: 1.64, color: 0xaaccff },
            { name: "Mintaka", ra: 5.53, dec: -0.3, mag: 2.23, color: 0xaaccff },
            { name: "Alnilam", ra: 5.60, dec: -1.2, mag: 1.70, color: 0xaaccff },
            { name: "Alnitak", ra: 5.67, dec: -1.94, mag: 1.77, color: 0xaaccff },
            { name: "Saiph", ra: 5.79, dec: -9.66, mag: 2.09, color: 0xaaccff },
            // Ursa Major (Big Dipper)
            { name: "Dubhe", ra: 11.06, dec: 61.75, mag: 1.79, color: 0xffaa55 },
            { name: "Merak", ra: 11.03, dec: 56.38, mag: 2.37, color: 0xffffff },
            { name: "Phecda", ra: 11.89, dec: 53.69, mag: 2.44, color: 0xffffff },
            { name: "Megrez", ra: 12.25, dec: 57.03, mag: 3.31, color: 0xffffff },
            { name: "Alioth", ra: 12.90, dec: 55.95, mag: 1.77, color: 0xffffff },
            { name: "Mizar", ra: 13.39, dec: 54.92, mag: 2.27, color: 0xffffff },
            { name: "Alkaid", ra: 13.79, dec: 49.31, mag: 1.86, color: 0xaaddff },
             // Cassiopeia
            { name: "Schedar", ra: 0.67, dec: 56.53, mag: 2.24, color: 0xffcc99 },
            { name: "Caph", ra: 0.15, dec: 59.15, mag: 2.28, color: 0xffffee },
            { name: "Gamma Cas", ra: 0.94, dec: 60.71, mag: 2.15, color: 0xaaddff },
            { name: "Ruchbah", ra: 1.43, dec: 60.23, mag: 2.68, color: 0xffffff },
            { name: "Segin", ra: 1.90, dec: 63.67, mag: 3.35, color: 0xffffff },
        ];

        const CONSTELLATIONS = [
            ["Betelgeuse", "Meissa"], ["Meissa", "Bellatrix"], ["Betelgeuse", "Alnitak"], ["Bellatrix", "Mintaka"], // Orion Body
            ["Mintaka", "Alnilam"], ["Alnilam", "Alnitak"], // Belt
            ["Alnitak", "Saiph"], ["Mintaka", "Rigel"], // Legs
            ["Dubhe", "Merak"], ["Merak", "Phecda"], ["Phecda", "Megrez"], ["Megrez", "Dubhe"], // Dipper Bowl
            ["Megrez", "Alioth"], ["Alioth", "Mizar"], ["Mizar", "Alkaid"], // Handle
            ["Caph", "Schedar"], ["Schedar", "Gamma Cas"], ["Gamma Cas", "Ruchbah"], ["Ruchbah", "Segin"] // Cassiopeia W
        ];

        const PLANET_DATA = [
            { name: "Sun", body: "Sun", color: 0xffff00, scale: 5 },
            { name: "Moon", body: "Moon", color: 0xcccccc, scale: 3 },
            { name: "Mercury", body: "Mercury", color: 0xaaaaaa, scale: 1 },
            { name: "Venus", body: "Venus", color: 0xffcc88, scale: 1.5 },
            { name: "Mars", body: "Mars", color: 0xff4422, scale: 1.2 },
            { name: "Jupiter", body: "Jupiter", color: 0xffaa77, scale: 2.5 },
            { name: "Saturn", body: "Saturn", color: 0xeecc88, scale: 2.2 },
        ];

        const DEEP_SKY = [
            { name: "Andromeda Galaxy", ra: 0.71, dec: 41.26, color: 0x88ccff, scale: 4, type: 'Galaxy' }
        ];

        /**
         * SCENE BUILDING
         */
        const skyRadius = 400;

        // Group to hold all celestial objects, rotated based on location/time
        const celestialGroup = new THREE.Group();
        scene.add(celestialGroup);

        // 1. Horizon Grid
        const gridHelper = new THREE.GridHelper(1000, 50, 0x004400, 0x002200);
        gridHelper.position.y = -2; // Slightly below camera
        scene.add(gridHelper);
        
        // Ground plane to block stars below horizon
        const groundGeo = new THREE.CircleGeometry(400, 32);
        const groundMat = new THREE.MeshBasicMaterial({ color: 0x000508, side: THREE.DoubleSide });
        const ground = new THREE.Mesh(groundGeo, groundMat);
        ground.rotation.x = -Math.PI / 2;
        ground.position.y = -2;
        scene.add(ground);

        // 2. Background Star Field (Procedural)
        function createStarField() {
            const geometry = new THREE.BufferGeometry();
            const count = 1500;
            const positions = [];
            const colors = [];
            const sizes = [];

            for (let i = 0; i < count; i++) {
                // Random spherical coordinates
                const theta = 2 * Math.PI * Math.random();
                const phi = Math.acos(2 * Math.random() - 1);
                const r = skyRadius;

                const x = r * Math.sin(phi) * Math.cos(theta);
                const y = r * Math.sin(phi) * Math.sin(theta);
                const z = r * Math.cos(phi);

                positions.push(x, y, z);
                
                // Random colors (white/blueish/reddish)
                const starType = Math.random();
                if(starType > 0.9) { colors.push(1, 0.8, 0.8); }
                else if(starType > 0.7) { colors.push(0.8, 0.8, 1); }
                else { colors.push(1, 1, 1); }

                sizes.push(Math.random() * 2);
            }

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));

            const material = new THREE.PointsMaterial({
                size: 2,
                vertexColors: true,
                map: texStar,
                transparent: true,
                opacity: 0.8,
                sizeAttenuation: false
            });

            const points = new THREE.Points(geometry, material);
            celestialGroup.add(points);
        }
        createStarField();

        // 3. Bright Stars & Planets Logic
        function addCelestialObject(name, ra, dec, color, scale, type, bodyType = null) {
            // Convert Equitorial (RA/Dec) to Cartesian on the celestial sphere
            // RA is in Hours (0-24), Dec in Degrees (-90 to +90)
            
            // Standard Astronomy conversion:
            // alpha = RA * 15 (deg)
            // delta = Dec (deg)
            // But we need to update these relative to Horizon every frame? 
            // APPROACH: We place objects in the "Celestial Group" using RA/Dec.
            // Then we rotate the Celestial Group based on Observer Latitude and Local Sidereal Time.
            // This is computationally cheaper than recalculating every object every frame.

            const phi = (90 - dec) * (Math.PI / 180);
            const theta = (ra * 15) * (Math.PI / 180); // RA hours to degrees to radians. Note: RA increases Eastward.
            
            // In Three.js: Y is up.
            // Cartesian on sphere:
            // x = r * sin(phi) * cos(theta)
            // z = r * sin(phi) * sin(theta) 
            // y = r * cos(phi)
            
            // Adjust for coordinate mapping: 
            // RA 0h is usually +X or +Z depending on convention. 
            // Let's use: Vernal Equinox (0h) = +X axis.
            
            const r = skyRadius;
            const x = r * Math.sin(phi) * Math.cos(theta);
            const z = -r * Math.sin(phi) * Math.sin(theta); // Flip Z to match RH system w/ RA direction
            const y = r * Math.cos(phi);

            // Mesh
            const geo = new THREE.SpriteMaterial({ 
                map: type === 'Planet' || type === 'Sun' || type === 'Moon' ? texPlanet : texStar, 
                color: color,
                transparent: true
            });
            const sprite = new THREE.Sprite(geo);
            
            // Adjust visual size
            let visualScale = 4;
            if(type === 'Star') visualScale = Math.max(2, 6 - (scale * 1.5)); // Magnitude logic
            else visualScale = scale * 5;

            sprite.scale.set(visualScale, visualScale, 1);
            sprite.position.set(x, y, z);
            sprite.name = name; // For Raycasting
            
            // Add metadata
            sprite.userData = { ra, dec, type, bodyType, originalColor: color };
            
            celestialGroup.add(sprite);
            
            // Add to App State for search
            AppState.objects.push(sprite);
            
            return sprite;
        }

        // Initialize Bright Stars
        BRIGHT_STARS.forEach(s => {
            addCelestialObject(s.name, s.ra, s.dec, s.color, s.mag, 'Star');
        });

        // Initialize Deep Sky
        DEEP_SKY.forEach(d => {
            addCelestialObject(d.name, d.ra, d.dec, d.color, d.scale, d.type);
        });

        // Draw Constellation Lines
        function drawConstellations() {
            const material = new THREE.LineBasicMaterial({ color: 0x224466, transparent: true, opacity: 0.5 });
            
            const points = [];
            CONSTELLATIONS.forEach(pair => {
                const s1 = AppState.objects.find(o => o.name === pair[0]);
                const s2 = AppState.objects.find(o => o.name === pair[1]);
                if (s1 && s2) {
                    points.push(s1.position);
                    points.push(s2.position);
                }
            });

            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const lines = new THREE.LineSegments(geometry, material);
            celestialGroup.add(lines);
        }
        drawConstellations();

        // Initialize Planets (Placeholders, updated later)
        const planetSprites = {};
        PLANET_DATA.forEach(p => {
            const s = addCelestialObject(p.name, 0, 0, p.color, p.scale, p.name === 'Sun' ? 'Sun' : 'Planet', p.body);
            planetSprites[p.name] = s;
        });


        /**
         * ASTRONOMY ENGINE INTEGRATION
         */
        function updatePlanetsAndSkyRotation() {
            if(!AppState.lat && !AppState.lon) return;

            const date = new Date();
            const observer = new Astronomy.Observer(AppState.lat, AppState.lon, 0);

            // 1. Calculate Local Sidereal Time (LST) to rotate the Celestial Sphere
            // The stars are fixed on the sphere (Right Ascension). The sphere rotates.
            // LST is the RA currently on the Meridian (South).
            // In ThreeJS world space, Z- is North, X+ is West (if Y is Up).
            // We need to align the Celestial Group so RA matches the sky.
            
            // Get GST (Greenwich Sidereal Time)
            const now = Astronomy.MakeTime(date);
            const gst = Astronomy.SiderealTime(now); // in hours
            const lst = (gst + AppState.lon / 15) % 24;
            
            // Rotation Calculation:
            // Rotate celestial sphere around Y axis (Earth's rotation).
            // We need RA=LST to be at Azimuth 180 (South) or 0 (North) depending on definition.
            // Let's rely on Horizon coordinates for Planets and just rotate Stars based on LST.
            
            // Actually, simpler approach for Hybrid:
            // Calculate Az/Alt for every object? Expensive for 1500 stars.
            // Rotate the Container Group.
            // Rotate Group around Z (tilt for Latitude) and Y (Spin for Time).
            
            // Step A: Correct for Latitude (Polaris Altitude = Latitude)
            // Rotate around X axis to tilt the pole?
            // Latitude 90 (North Pole) -> Polaris directly up.
            // Latitude 0 (Equator) -> Polaris at horizon.
            // In ThreeJS: Y is up. Celestial Pole (Dec 90) needs to point at Y if we were at Pole.
            // If we are at Lat L, Pole is at Angle L from Horizon.
            
            // Reset rotation
            celestialGroup.rotation.set(0,0,0);
            
            // 1. Rotate for Time (Sidereal). 
            // Determine RA of Meridian. 
            // Rotation = -LST * 15 deg (since Earth rotates East, Sky rotates West).
            // Offset to match coordinate system.
            const skyRotationY = -lst * (Math.PI / 12); // Hours to Radians
            celestialGroup.rotateY(skyRotationY); 

            // 2. Rotate for Latitude.
            // Tilt the whole sphere so the Pole (Y axis of sphere) points to correct Altitude.
            // Co-latitude tilt around X axis.
            const latRad = AppState.lat * (Math.PI / 180);
            const tilt = (Math.PI / 2) - latRad;
            // We need to apply this tilt relative to the local horizon, NOT global axes directly 
            // if we just rotated Y.
            // Better: Set Quaternion.
            
            // Correct Math for aligning Equatorial Grid to Horizontal Grid:
            // 1. Rotate West by LST.
            // 2. Tilt down by Co-Latitude.
            
            // Let's use Rotation Matrix approach manually for sanity.
            // The Celestial Group contains objects placed by RA/Dec.
            // Object(x,y,z) is in Equatorial Frame.
            // We want to move them to Horizontal Frame (World Space).
            // Matrix: Rx(-(90-Lat)) * Ry(-LST) ?
            
            // Actually, Astronomy Engine calculates apparent position (Az/Alt).
            // Let's use that for Planets accurately.
            // For Stars, we approximate by rotating the group.
            // The "Zero" of our star creation was RA=0 at +X, Dec=90 at +Y.
            
            // Aligning the Star Sphere:
            // 1. Spin around Y (Polar Axis) so RA=LST is aligned with Meridian.
            //    Our Meridian is -Z (North) -> +Z (South). 
            // 2. Tilt X axis so Pole (Y) goes to Latitude angle.
            
            const axisX = new THREE.Vector3(1, 0, 0);
            const axisY = new THREE.Vector3(0, 1, 0);
            
            // Reset
            celestialGroup.quaternion.setFromAxisAngle(axisY, 0);
            
            // Time rotation: Align RA to local meridian.
            // Offset: We built RA 0 at +X.
            // We want RA = LST to be at South (+Z).
            // Rotation angle = (LST - RA_0) ... 
            // Let's assume standard rotation:
            const rotZ = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0,0,1), 0); // No roll
            
            // Construct rotation matrix from Equator to Horizon
            // Using standard formula components is safer than guessing Euler orders.
            // But for this simplified app:
            celestialGroup.rotation.order = 'YXZ';
            celestialGroup.rotation.y = (Math.PI/2) - (lst * Math.PI/12); // Align RA
            celestialGroup.rotation.x = latRad - (Math.PI/2); // Tilt for Latitude
            
            // Update Planet Positions accurately (Calculated individually, ignoring group rotation)
            // We must put planets inside the scene DIRECTLY, not in celestialGroup, 
            // OR counter-rotate them. 
            // EASIER: Put planets in World Space.
            
            PLANET_DATA.forEach(p => {
                const sprite = planetSprites[p.name];
                if(sprite) {
                    // Detach from celestialGroup if needed or just handle calc.
                    // Let's attach planets to SCENE, not Group, for accuracy.
                    if(sprite.parent === celestialGroup) {
                        scene.attach(sprite); 
                    }
                    
                    const body = Astronomy.Body[p.body];
                    const equ = Astronomy.Equator(body, now, observer, true, true);
                    const hor = Astronomy.Horizon(now, observer, equ.ra, equ.dec, 'normal');
                    
                    // Convert Az/Alt to XYZ
                    // Az is measured from North (0) increasing East (90).
                    // In ThreeJS: -Z is North. +X is East.
                    const az = hor.azimuth; 
                    const alt = hor.altitude;
                    
                    const r = skyRadius * 0.9; // Slightly in front of stars
                    const phi = (90 - alt) * (Math.PI / 180);
                    const theta = (90 - az) * (Math.PI / 180); // Adjusting Az to Math angle
                    
                    // x = r sin(phi) cos(theta)
                    // z = r sin(phi) sin(theta) -> mapped to -z north
                    // y = r cos(phi)
                    
                    // Three JS coords:
                    // North (-Z) corresponds to Az 0.
                    // East (+X) corresponds to Az 90.
                    // South (+Z) corresponds to Az 180.
                    // West (-X) corresponds to Az 270.
                    
                    // Math angle 0 is +X.
                    // Az 90 -> Math 0.
                    // Az 0 -> Math 90.
                    // Math Angle = 90 - Az.
                    
                    const radAz = (90 - az) * (Math.PI / 180);
                    const radAlt = alt * (Math.PI / 180);
                    
                    sprite.position.x = r * Math.cos(radAlt) * Math.cos(radAz);
                    sprite.position.y = r * Math.sin(radAlt);
                    sprite.position.z = -r * Math.cos(radAlt) * Math.sin(radAz); // -sin because Z is inverted
                    
                    // Update UserData for UI
                    sprite.userData.az = az;
                    sprite.userData.alt = alt;
                    sprite.userData.ra = equ.ra;
                    sprite.userData.dec = equ.dec;
                }
            });
        }

        /**
         * CONTROLS (Custom Touch Look)
         */
        const touchState = { x: 0, y: 0, active: false, lastDist: 0 };
        
        document.addEventListener('mousedown', e => {
            touchState.active = true;
            touchState.x = e.clientX;
            touchState.y = e.clientY;
        });
        document.addEventListener('mouseup', () => touchState.active = false);
        document.addEventListener('mousemove', e => handleInput(e.clientX, e.clientY));

        document.addEventListener('touchstart', e => {
            touchState.active = true;
            if(e.touches.length === 1) {
                touchState.x = e.touches[0].clientX;
                touchState.y = e.touches[0].clientY;
            } else if (e.touches.length === 2) {
                const dx = e.touches[0].clientX - e.touches[1].clientX;
                const dy = e.touches[0].clientY - e.touches[1].clientY;
                touchState.lastDist = Math.hypot(dx, dy);
            }
        }, {passive: false});

        document.addEventListener('touchend', () => touchState.active = false);
        document.addEventListener('touchmove', e => {
            e.preventDefault(); // Stop scrolling
            if(e.touches.length === 1) {
                handleInput(e.touches[0].clientX, e.touches[0].clientY);
            } else if (e.touches.length === 2) {
                // Pinch Zoom
                const dx = e.touches[0].clientX - e.touches[1].clientX;
                const dy = e.touches[0].clientY - e.touches[1].clientY;
                const dist = Math.hypot(dx, dy);
                const delta = touchState.lastDist - dist;
                
                camera.fov += delta * 0.1;
                camera.fov = Math.max(20, Math.min(100, camera.fov));
                camera.updateProjectionMatrix();
                
                touchState.lastDist = dist;
            }
        }, {passive: false});

        function handleInput(x, y) {
            if (!touchState.active) return;
            const dx = x - touchState.x;
            const dy = y - touchState.y;

            AppState.lonStart -= dx * 0.2;
            AppState.latStart += dy * 0.2;
            AppState.latStart = Math.max(-85, Math.min(85, AppState.latStart));

            touchState.x = x;
            touchState.y = y;
        }

        /**
         * UI LOGIC (Search & Raycast)
         */
        // Populate Search
        function initSearch() {
            const list = AppState.objects.map(o => o.name);
            elSearchInput.addEventListener('input', (e) => {
                const val = e.target.value.toLowerCase();
                elSearchResults.innerHTML = '';
                if(!val) {
                    elSearchResults.style.display = 'none';
                    return;
                }
                const matches = list.filter(n => n.toLowerCase().includes(val));
                matches.forEach(name => {
                    const div = document.createElement('div');
                    div.className = 'result-item';
                    div.innerText = name;
                    div.onclick = () => selectObject(name);
                    elSearchResults.appendChild(div);
                });
                elSearchResults.style.display = matches.length ? 'block' : 'none';
            });
        }
        
        function selectObject(name) {
            const obj = AppState.objects.find(o => o.name === name);
            if(obj) {
                AppState.targetObject = obj;
                elSearchInput.value = name;
                elSearchResults.style.display = 'none';
                
                // Highlight color
                AppState.objects.forEach(o => o.material.color.setHex(o.userData.originalColor));
                obj.material.color.setHex(0xff00ff);
            }
        }

        function updateGuidanceArrow() {
            if(!AppState.targetObject) {
                elArrow.style.display = 'none';
                return;
            }

            // Project object position to 2D screen
            const vector = AppState.targetObject.position.clone();
            
            // Check if behind camera
            const cameraDir = new THREE.Vector3();
            camera.getWorldDirection(cameraDir);
            const angle = vector.angleTo(cameraDir);
            const isBehind = angle > Math.PI / 2;

            vector.project(camera);

            const hw = window.innerWidth / 2;
            const hh = window.innerHeight / 2;
            
            let x = (vector.x * hw) + hw;
            let y = -(vector.y * hh) + hh;

            // Screen bounds logic
            const padding = 40;
            const onScreen = (x > padding && x < window.innerWidth - padding && y > padding && y < window.innerHeight - padding && !isBehind);

            if(onScreen) {
                elArrow.style.display = 'none'; // Object is visible
                // Optional: Draw a box around it (omitted for clean code)
            } else {
                elArrow.style.display = 'block';
                
                // Calculate rotation for the arrow
                // Center is hw, hh
                let dx = x - hw;
                let dy = y - hh;
                
                // If behind, invert direction
                if (isBehind) {
                    dx = -dx;
                    dy = -dy;
                }

                const rad = Math.atan2(dy, dx);
                const deg = rad * (180/Math.PI) + 90; // +90 because arrow points down in CSS

                // Clamp to edges
                // Simple logic: Place on a circle or box edge.
                // Circle is smoother
                const radius = Math.min(hw, hh) - 50;
                const arrX = hw + radius * Math.cos(rad);
                const arrY = hh + radius * Math.sin(rad);

                elArrow.style.left = arrX + 'px';
                elArrow.style.top = arrY + 'px';
                elArrow.style.transform = `translate(-50%, -50%) rotate(${deg}deg)`;
            }
        }

        /**
         * MAIN LOOP
         */
        function animate() {
            requestAnimationFrame(animate);

            // Update Camera Rotation based on drag
            AppState.phi = THREE.MathUtils.degToRad(90 - AppState.latStart);
            AppState.theta = THREE.MathUtils.degToRad(AppState.lonStart);
            
            const targetX = 500 * Math.sin(AppState.phi) * Math.cos(AppState.theta);
            const targetY = 500 * Math.cos(AppState.phi);
            const targetZ = 500 * Math.sin(AppState.phi) * Math.sin(AppState.theta);
            
            camera.lookAt(targetX, targetY, targetZ);

            // Raycasting for Info Panel
            raycaster.setFromCamera(centerPoint, camera);
            const intersects = raycaster.intersectObjects(celestialGroup.children.concat(scene.children)); // Check all
            
            let hit = intersects.find(i => i.object.type === 'Sprite'); // Find first sprite
            
            if (hit) {
                const d = hit.object.userData;
                elInfo.style.opacity = 1;
                elInfoName.innerText = hit.object.name;
                // If planet, show Az/Alt. If star, show RA/Dec or calculated Az/Alt
                if(d.az) {
                    elInfoCoords.innerText = `Az: ${d.az.toFixed(1)}° Alt: ${d.alt.toFixed(1)}°`;
                } else {
                    elInfoCoords.innerText = `RA: ${d.ra}h Dec: ${d.dec}°`;
                }
            } else {
                elInfo.style.opacity = 0;
            }

            updateGuidanceArrow();

            renderer.render(scene, camera);
        }

        /**
         * INIT
         */
        function init() {
            initSearch();
            
            if (navigator.geolocation) {
                navigator.geolocation.getCurrentPosition(
                    (pos) => {
                        AppState.lat = pos.coords.latitude;
                        AppState.lon = pos.coords.longitude;
                        elLoadingText.innerText = `Loc: ${AppState.lat.toFixed(2)}, ${AppState.lon.toFixed(2)}`;
                        setTimeout(() => {
                            updatePlanetsAndSkyRotation();
                            elLoading.style.display = 'none';
                            animate();
                            // Update sky every minute
                            setInterval(updatePlanetsAndSkyRotation, 60000); 
                        }, 1000);
                    },
                    (err) => {
                        console.warn("GPS Denied, using default (Greenwich)");
                        elLoadingText.innerText = "GPS Denied. Using Default.";
                        setTimeout(() => {
                            AppState.lat = 51.4; AppState.lon = 0; // London
                            updatePlanetsAndSkyRotation();
                            elLoading.style.display = 'none';
                            animate();
                        }, 1500);
                    }
                );
            } else {
                AppState.lat = 51.4; AppState.lon = 0;
                updatePlanetsAndSkyRotation();
                elLoading.style.display = 'none';
                animate();
            }
        }
        
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        init();

    </script>
</body>
</html>
