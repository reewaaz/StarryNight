<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>3D Sky Viewer</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Segoe UI', sans-serif; }
        canvas { display: block; }
        
        /* HUD Overlay */
        #hud {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; /* Touches pass through to canvas/listeners */
            display: flex; flex-direction: column; justify-content: space-between;
        }

        /* Top Search Bar */
        .top-bar {
            padding: 15px;
            background: linear-gradient(to bottom, rgba(0,0,0,0.8), transparent);
            display: flex; gap: 10px; pointer-events: auto;
        }
        
        input#search {
            flex-grow: 1; background: rgba(0, 20, 40, 0.6); border: 1px solid #00ffff;
            color: #fff; padding: 10px; border-radius: 20px; font-size: 16px; outline: none;
        }
        button#searchBtn {
            background: #00ffff; color: #000; border: none; padding: 0 20px;
            border-radius: 20px; font-weight: bold; cursor: pointer;
        }

        /* Center Reticle */
        .reticle {
            position: absolute; top: 50%; left: 50%;
            width: 50px; height: 50px;
            transform: translate(-50%, -50%);
            border: 1px solid rgba(0, 255, 255, 0.5);
            border-radius: 50%;
            box-shadow: 0 0 15px rgba(0,255,255,0.1);
        }
        .reticle::after {
            content: ''; position: absolute; top: 50%; left: 50%;
            width: 4px; height: 4px; background: #fff;
            transform: translate(-50%, -50%); border-radius: 50%;
        }

        /* Bottom Info Panel */
        #infoPanel {
            margin: 20px; padding: 15px;
            background: rgba(0, 10, 20, 0.8);
            border-left: 3px solid #00ffff;
            color: #fff; pointer-events: auto;
            backdrop-filter: blur(5px);
        }
        #infoPanel h2 { margin: 0 0 5px 0; font-size: 20px; color: #00ffff; text-shadow: 0 0 10px rgba(0,255,255,0.5); }
        #infoPanel .sub { font-size: 12px; color: #aaa; }

        /* Guidance Arrow */
        #guideArrow {
            position: absolute; top: 50%; left: 50%;
            width: 0; height: 0; display: none;
            border-left: 12px solid transparent;
            border-right: 12px solid transparent;
            border-bottom: 20px solid #ff0055;
            transform-origin: 50% 120px; /* Orbit radius around center */
            opacity: 0.9; filter: drop-shadow(0 0 5px #ff0055);
        }
    </style>
    
    <!-- Import Maps -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    <script src="https://unpkg.com/astronomy-engine@2.0.0/astronomy-browser.js"></script>
</head>
<body>

    <!-- HUD -->
    <div id="hud">
        <div class="top-bar">
            <input type="text" id="search" placeholder="Search Sky...">
            <button id="searchBtn">üîç</button>
        </div>
        <div class="reticle"></div>
        <div id="guideArrow"></div>
        <div id="infoPanel">
            <h2 id="objName">Initializing...</h2>
            <div id="objCoords" class="sub">Acquiring GPS...</div>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { DeviceOrientationControls } from 'three/addons/controls/DeviceOrientationControls.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- Config ---
        const config = { starCount: 2500, constellationColor: 0x4444ff };
        const state = {
            lat: 0, lon: 0,
            objects: [],
            targetObject: null,
            controls: null,
            sensorActive: false
        };

        // --- Data ---
        // Simplified Bright Star Catalog
        const brightStars = [
            { ra: 6.75, dec: -16.7, name: "Sirius", mag: -1.46 }, { ra: 18.6, dec: 38.8, name: "Vega", mag: 0.03 },
            { ra: 5.25, dec: 46.0, name: "Capella", mag: 0.08 }, { ra: 19.8, dec: 8.9, name: "Altair", mag: 0.77 },
            { ra: 4.6, dec: 16.5, name: "Aldebaran", mag: 0.85 }, { ra: 5.9, dec: 7.4, name: "Betelgeuse", mag: 0.5 },
            { ra: 5.2, dec: -8.2, name: "Rigel", mag: 0.12 }, { ra: 14.2, dec: 19.1, name: "Arcturus", mag: -0.04 },
            { ra: 16.5, dec: -26.4, name: "Antares", mag: 0.96 }, { ra: 20.7, dec: 45.3, name: "Deneb", mag: 1.25 },
            { ra: 11.0, dec: 61.75, name: "Dubhe", mag: 1.8 }, { ra: 11.03, dec: 56.38, name: "Merak", mag: 2.3 },
            { ra: 13.8, dec: 49.3, name: "Alkaid", mag: 1.8 }, { ra: 1.16, dec: 88.3, name: "Polaris", mag: 1.9 }
        ];

        const constellations = [
            ["Betelgeuse", "Rigel"], // Orion (Simple)
            ["Dubhe", "Merak"], ["Merak", "Alkaid"] // Dipper (Very Simple)
        ];

        // --- Scene Setup ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.001);
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        const celestialGroup = new THREE.Group();
        scene.add(celestialGroup);

        // --- Textures ---
        function createTex(color, stops) {
            const cvs = document.createElement('canvas');
            cvs.width = 64; cvs.height = 64;
            const ctx = cvs.getContext('2d');
            const grad = ctx.createRadialGradient(32,32,0, 32,32,32);
            stops.forEach(s => grad.addColorStop(s[0], s[1]));
            ctx.fillStyle = grad; ctx.fillRect(0,0,64,64);
            return new THREE.CanvasTexture(cvs);
        }
        const starTex = createTex('white', [[0,'#fff'], [0.2, 'rgba(255,255,255,0.8)'], [1, 'transparent']]);
        const planetTex = createTex('white', [[0,'#fff'], [0.4, '#88ccff'], [1, 'transparent']]);
        const sunTex = createTex('orange', [[0,'#fff'], [0.2, '#ffaa00'], [1, 'transparent']]);

        // --- Celestial Objects ---
        // 1. Background
        const starGeo = new THREE.BufferGeometry();
        const starPos = [];
        for(let i=0; i<config.starCount; i++) {
            const theta = 2 * Math.PI * Math.random();
            const phi = Math.acos(2 * Math.random() - 1);
            const r = 450;
            starPos.push(r * Math.sin(phi) * Math.cos(theta), r * Math.sin(phi) * Math.sin(theta), r * Math.cos(phi));
        }
        starGeo.setAttribute('position', new THREE.Float32BufferAttribute(starPos, 3));
        celestialGroup.add(new THREE.Points(starGeo, new THREE.PointsMaterial({ color: 0x666666, size: 1.5 })));

        // 2. Bright Stars
        const starMat = new THREE.SpriteMaterial({ map: starTex, color: 0xffffff });
        const starMap = {};
        brightStars.forEach(s => {
            const pos = raDecToVector(s.ra, s.dec, 400);
            const mesh = new THREE.Sprite(starMat);
            mesh.position.copy(pos);
            const scale = Math.max(3, 8 - s.mag*2);
            mesh.scale.set(scale, scale, 1);
            mesh.userData = { name: s.name, type: 'Star' };
            celestialGroup.add(mesh);
            state.objects.push(mesh);
            starMap[s.name] = mesh;
        });

        // 3. Planets
        const planets = [
            { name: 'Sun', tex: sunTex, scale: 25, color: 0xffaa00 },
            { name: 'Moon', tex: planetTex, scale: 18, color: 0xeeeeee },
            { name: 'Venus', tex: planetTex, scale: 8, color: 0xffccaa },
            { name: 'Mars', tex: planetTex, scale: 7, color: 0xff5500 },
            { name: 'Jupiter', tex: planetTex, scale: 12, color: 0xffccaa },
            { name: 'Saturn', tex: planetTex, scale: 10, color: 0xeeddaa }
        ];
        const planetMap = {};
        planets.forEach(p => {
            const mesh = new THREE.Sprite(new THREE.SpriteMaterial({ map: p.tex, color: p.color }));
            mesh.scale.set(p.scale, p.scale, 1);
            mesh.userData = { name: p.name, type: 'Solar System' };
            celestialGroup.add(mesh);
            state.objects.push(mesh);
            planetMap[p.name] = mesh;
        });

        // 4. Horizon Grid
        const grid = new THREE.PolarGridHelper(200, 16, 8, 64, 0x003300, 0x001100);
        grid.position.y = -5;
        scene.add(grid);

        // --- Math ---
        function raDecToVector(ra, dec, r) {
            const phi = (90 - dec) * (Math.PI / 180);
            const theta = (ra * 15) * (Math.PI / 180);
            return new THREE.Vector3(
                r * Math.sin(theta) * Math.cos(dec * Math.PI/180),
                r * Math.sin(dec * Math.PI/180),
                -r * Math.cos(theta) * Math.cos(dec * Math.PI/180)
            );
        }

        function updatePositions() {
            if(!state.lat) return;
            const now = Astronomy.MakeTime(new Date());
            const obs = new Astronomy.Observer(state.lat, state.lon, 0);
            
            // Update Planets
            planets.forEach(p => {
                if(p.name === 'Sun') return; // Handled generically or simplified
                const equ = Astronomy.Equator(p.name, now, obs, true, true);
                planetMap[p.name].position.copy(raDecToVector(equ.ra, equ.dec, 380));
            });
            // Sun
            const sunEq = Astronomy.Equator('Sun', now, obs, true, true);
            planetMap['Sun'].position.copy(raDecToVector(sunEq.ra, sunEq.dec, 380));

            // Rotate Universe
            celestialGroup.rotation.set(0,0,0);
            const gst = Astronomy.SiderealTime(now);
            const lst = gst + state.lon/15;
            const rotZ = -lst * 15 * (Math.PI/180); // Earth rotation
            const tilt = (90 - state.lat) * (Math.PI/180); // Lat tilt

            const qLST = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0,1,0), -rotZ);
            const qTilt = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(1,0,0), -tilt);
            celestialGroup.quaternion.copy(qTilt).multiply(qLST);
        }

        // --- Initialization & sensors ---
        async function initSensors() {
            // 1. GPS
            if (navigator.geolocation) {
                navigator.geolocation.getCurrentPosition(pos => {
                    state.lat = pos.coords.latitude;
                    state.lon = pos.coords.longitude;
                    document.getElementById('objCoords').textContent = `GPS: ${state.lat.toFixed(2)}, ${state.lon.toFixed(2)}`;
                    updatePositions();
                }, err => {
                    console.warn("GPS Fail", err);
                    document.getElementById('objCoords').textContent = "GPS Failed. Assuming Equator.";
                });
            }

            // 2. Orientation
            // Strategy: Create DeviceOrientationControls immediately.
            // On iOS 13+, this might fail silently or not receive events until permitted.
            // On Android/Old iOS, this works immediately.
            state.controls = new DeviceOrientationControls(camera);
            state.controls.connect();
            state.sensorActive = true;

            // Fallback for touch rotation if sensors aren't actually moving things
            // We'll add a temporary OrbitControl listener just in case, but usually we swap based on event data.
            // Simpler approach:
            // Add a global 'click' listener. If sensors are blocked (iOS requires interaction),
            // the first tap on the screen will request permission.
            window.addEventListener('click', requestIOSPermission, { once: true });
            window.addEventListener('touchstart', requestIOSPermission, { once: true });
        }

        async function requestIOSPermission() {
            // This function is only useful for iOS 13+ which requires a gesture to start sensors
            if (typeof DeviceMotionEvent !== 'undefined' && typeof DeviceMotionEvent.requestPermission === 'function') {
                try {
                    const response = await DeviceMotionEvent.requestPermission();
                    if (response === 'granted') {
                        // Re-initialize controls to ensure they bind
                        state.controls.dispose();
                        state.controls = new DeviceOrientationControls(camera);
                        state.controls.connect();
                    }
                } catch (e) { console.error(e); }
            }
        }

        // --- Loop ---
        const raycaster = new THREE.Raycaster();
        const center = new THREE.Vector2(0,0);

        function animate() {
            requestAnimationFrame(animate);
            if(state.controls) state.controls.update();
            
            // HUD Logic
            raycaster.setFromCamera(center, camera);
            const hits = raycaster.intersectObjects(state.objects);
            if(hits.length > 0) {
                const name = hits[0].object.userData.name;
                document.getElementById('objName').textContent = name;
                document.getElementById('objName').style.color = '#00ffff';
            } else {
                document.getElementById('objName').textContent = "Scanning...";
                document.getElementById('objName').style.color = '#888';
            }

            // Arrow
            if(state.targetObject) {
                const arrow = document.getElementById('guideArrow');
                const v = state.targetObject.getWorldPosition(new THREE.Vector3());
                v.project(camera);
                if(v.z < 1 && v.x > -0.9 && v.x < 0.9 && v.y > -0.9 && v.y < 0.9) {
                    arrow.style.display = 'none';
                } else {
                    arrow.style.display = 'block';
                    const angle = Math.atan2(v.y, v.x) * (180/Math.PI); 
                    // Simple compass logic - if z > 1 it's behind, flip logic
                    const rotation = (v.z > 1) ? angle : angle + 180; 
                    // CSS Rotation is visually tweaked
                    const cx = window.innerWidth/2; const cy = window.innerHeight/2;
                    // Improved Arrow logic:
                    // If behind (z>1), invert vector.
                    const dx = v.x; const dy = v.y;
                    const finalAngle = Math.atan2(dy, dx) * 180 / Math.PI - 90;
                    arrow.style.transform = `translate(-50%, -50%) rotate(${finalAngle}deg) translateY(120px)`;
                }
            }

            renderer.render(scene, camera);
        }

        // --- Interaction ---
        document.getElementById('searchBtn').addEventListener('click', () => {
            const val = document.getElementById('search').value.toLowerCase();
            const found = state.objects.find(o => o.userData.name.toLowerCase().includes(val));
            if(found) {
                state.targetObject = found;
                alert(`Target set: ${found.userData.name}. Follow the red arrow.`);
            } else {
                alert("Object not found.");
            }
        });

        // Zoom
        let pinchStart = 0;
        window.addEventListener('touchstart', e => { if(e.touches.length===2) pinchStart = Math.hypot(e.touches[0].pageX-e.touches[1].pageX, e.touches[0].pageY-e.touches[1].pageY); });
        window.addEventListener('touchmove', e => { 
            if(e.touches.length===2) {
                const d = Math.hypot(e.touches[0].pageX-e.touches[1].pageX, e.touches[0].pageY-e.touches[1].pageY);
                camera.fov = THREE.MathUtils.clamp(camera.fov + (pinchStart - d)*0.1, 20, 100);
                camera.updateProjectionMatrix();
                pinchStart = d;
            }
        });

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Boot
        initSensors();
        animate();
        setInterval(updatePositions, 5000); // Update physics every 5s

    </script>
</body>
</html>
