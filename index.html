<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Starry Night Debug</title>
    
    <!-- External Math Library (Global Script) -->
    <script src="https://cdn.jsdelivr.net/npm/astronomy-engine@2.1.19/astronomy.browser.min.js"></script>

    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: sans-serif; color: white; }
        canvas { display: block; width: 100vw; height: 100vh; }

        /* UI Overlay */
        #ui {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; display: flex; flex-direction: column;
        }

        /* Top Search */
        #top-bar {
            padding: 10px; pointer-events: auto; background: linear-gradient(rgba(0,0,0,0.8), transparent);
        }
        input {
            width: 100%; box-sizing: border-box; padding: 10px;
            background: rgba(255,255,255,0.2); border: 1px solid #555;
            color: white; border-radius: 8px; backdrop-filter: blur(5px);
        }

        /* Center Reticle */
        #reticle {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            width: 40px; height: 40px; border: 2px solid cyan; border-radius: 50%;
            box-shadow: 0 0 10px cyan; opacity: 0.7;
        }

        /* Compass Strip */
        #compass {
            position: absolute; top: 60px; left: 0; width: 100%; height: 30px;
            background: rgba(0,0,0,0.5); overflow: hidden; white-space: nowrap;
            display: flex; align-items: center; border-top: 1px solid #333; border-bottom: 1px solid #333;
        }
        #compass-inner { position: relative; left: 50%; transition: transform 0.1s linear; }
        .tick { display: inline-block; width: 50px; text-align: center; font-size: 12px; color: #aaa; border-left: 1px solid #444; }

        /* Bottom Info */
        #info {
            margin-top: auto; padding: 20px; background: rgba(0,0,0,0.8);
            border-top: 1px solid #333; pointer-events: auto;
        }
        h2 { margin: 0; color: cyan; font-size: 1.2rem; }
        p { margin: 5px 0 0; color: #ccc; font-size: 0.9rem; }

        /* Start Button / Overlay */
        #overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85); z-index: 999;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
        }
        button {
            padding: 15px 40px; font-size: 18px; background: cyan; border: none;
            border-radius: 30px; cursor: pointer; color: #000; font-weight: bold;
            margin-bottom: 20px; pointer-events: auto;
        }

        /* Debug Console */
        #console-log {
            position: absolute; bottom: 0; left: 0; width: 100%; height: 100px;
            background: rgba(50,0,0,0.8); color: #ffaaaa; font-family: monospace;
            font-size: 10px; overflow-y: auto; pointer-events: none; z-index: 1000;
            padding: 5px; box-sizing: border-box; border-top: 1px solid red;
            display: block; /* Visible for troubleshooting */
        }
    </style>

    <!-- Three.js Import Map -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <!-- Debug Log -->
    <div id="console-log">Initializing...<br></div>

    <!-- UI -->
    <div id="ui">
        <div id="top-bar">
            <input id="search" type="text" placeholder="Search planet...">
        </div>
        <div id="compass"><div id="compass-inner"><!-- JS fills this --></div></div>
        <div id="reticle"></div>
        <div id="info">
            <h2 id="target-name">Sky View</h2>
            <p id="target-coords">Drag to look around</p>
        </div>
    </div>

    <!-- Start Overlay -->
    <div id="overlay">
        <h1 style="color:white; margin-bottom:0;">Starry Night</h1>
        <p style="color:#aaa; margin-bottom:30px;">Troubleshoot Mode</p>
        <button id="btn-start">ENABLE SENSORS</button>
        <p style="font-size: 12px; color: #666;">If sensors fail, touch drag still works.</p>
    </div>

    <!-- Error Handling Script -->
    <script>
        const logDiv = document.getElementById('console-log');
        function log(msg, color="#fff") {
            const line = document.createElement('div');
            line.style.color = color;
            line.innerText = `> ${msg}`;
            logDiv.appendChild(line);
            logDiv.scrollTop = logDiv.scrollHeight;
            console.log(msg);
        }
        
        window.onerror = function(msg, url, line) {
            log(`ERROR: ${msg} (Line ${line})`, '#ff5555');
        };

        if (location.protocol === 'file:') {
            log("CRITICAL WARNING: App running via file:// protocol.", 'yellow');
            log("Sensors WILL NOT work. Please host on GitHub Pages or local server.", 'yellow');
        }
    </script>

    <!-- Main Application -->
    <script type="module">
        import * as THREE from 'three';
        import { DeviceOrientationControls } from 'three/addons/controls/DeviceOrientationControls.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        let scene, camera, renderer;
        let sensorControls, touchControls;
        let celestialObjects = [];
        let raycaster, center;
        let activeControlMode = 'touch'; // 'touch' or 'sensors'
        let userLoc = { lat: 0, lon: 0 };
        let isRunning = true;
        let arrowGuide;
        let compassEl;

        // UI Elements
        const uiName = document.getElementById('target-name');
        const uiCoords = document.getElementById('target-coords');
        const overlay = document.getElementById('overlay');
        const startBtn = document.getElementById('btn-start');
        const searchInput = document.getElementById('search');

        // --- 1. Initialization ---
        function init() {
            log("Starting 3D Engine...");
            
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x050510);
            scene.fog = new THREE.FogExp2(0x050510, 0.0004);

            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
            camera.position.set(0, 0, 0.1);

            // Renderer
            try {
                renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setPixelRatio(window.devicePixelRatio);
                document.body.appendChild(renderer.domElement);
                log("WebGL Initialized.");
            } catch (e) {
                log("WebGL Failed: " + e.message, 'red');
                return;
            }

            // Controls (Start with Orbit/Touch)
            touchControls = new OrbitControls(camera, renderer.domElement);
            touchControls.enableZoom = false;
            touchControls.enablePan = false;
            touchControls.rotateSpeed = 0.5;

            // Content
            createStars();
            createGrid();
            createArrow();
            createCompassTicks();

            // Setup Raycaster
            raycaster = new THREE.Raycaster();
            center = new THREE.Vector2(0, 0);

            // Events
            window.addEventListener('resize', onResize);
            
            // Start Loop immediately (don't wait for sensors)
            renderer.setAnimationLoop(animate);
        }

        // --- 2. Content Creation ---
        function createStars() {
            const count = 1500;
            const geom = new THREE.BufferGeometry();
            const pos = [];
            for(let i=0; i<count; i++) {
                const r = 1000;
                const theta = 2 * Math.PI * Math.random();
                const phi = Math.acos(2 * Math.random() - 1);
                pos.push(
                    r * Math.sin(phi) * Math.cos(theta),
                    r * Math.sin(phi) * Math.sin(theta),
                    r * Math.cos(phi)
                );
            }
            geom.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
            const mat = new THREE.PointsMaterial({ color: 0xffffff, size: 2 });
            scene.add(new THREE.Points(geom, mat));
        }

        function createGrid() {
            const grid = new THREE.PolarGridHelper(800, 16, 8, 64, 0x333333, 0x111111);
            grid.position.y = -10;
            scene.add(grid);
        }

        function createArrow() {
            // Guide Arrow attached to camera
            const geom = new THREE.ConeGeometry(0.5, 2, 8);
            geom.rotateX(Math.PI/2); 
            const mat = new THREE.MeshBasicMaterial({ color: 0xffff00, transparent: true, opacity: 0.5, depthTest: false });
            arrowGuide = new THREE.Mesh(geom, mat);
            arrowGuide.position.set(0, -2, -5); // Below center
            arrowGuide.visible = false;
            camera.add(arrowGuide);
            scene.add(camera);
        }

        function createCompassTicks() {
            compassEl = document.getElementById('compass-inner');
            let html = '';
            // N E S W repeated
            const dirs = ['N','NE','E','SE','S','SW','W','NW','N','NE','E','SE','S','SW','W','NW'];
            dirs.forEach(d => {
                html += `<div class="tick">${d}</div>`;
            });
            compassEl.innerHTML = html;
        }

        // --- 3. Logic & Updates ---
        
        function updateObjects() {
            if(!userLoc.lat) return;
            const date = new Date();
            const observer = new Astronomy.Observer(userLoc.lat, userLoc.lon, 0);
            
            const bodies = [
                { name: 'Sun', obj: Astronomy.Body.Sun, color: 0xFFD700, size: 30 },
                { name: 'Moon', obj: Astronomy.Body.Moon, color: 0xCCCCCC, size: 25 },
                { name: 'Mars', obj: Astronomy.Body.Mars, color: 0xFF4500, size: 10 },
                { name: 'Venus', obj: Astronomy.Body.Venus, color: 0xFFDD88, size: 12 },
                { name: 'Jupiter', obj: Astronomy.Body.Jupiter, color: 0xDDAA77, size: 20 },
                { name: 'Saturn', obj: Astronomy.Body.Saturn, color: 0xD4C86A, size: 18 }
            ];

            bodies.forEach(b => {
                const equ = Astronomy.Equator(b.obj, date, observer, false, true);
                const hor = Astronomy.Horizon(date, observer, equ.ra, equ.dec, 'normal');

                // Positioning logic (Y-up)
                // Azimuth 0 is North. 3js Z- is North (if camera aligned).
                const r = 800;
                const phi = (90 - hor.altitude) * (Math.PI/180);
                const theta = -hor.azimuth * (Math.PI/180); // Negate for coordinate system match

                const x = r * Math.sin(theta) * Math.sin(phi);
                const y = r * Math.cos(phi);
                const z = r * Math.cos(theta) * Math.sin(phi);

                let mesh = celestialObjects.find(o => o.userData.name === b.name);
                if(!mesh) {
                    mesh = new THREE.Mesh(
                        new THREE.SphereGeometry(b.size, 16, 16),
                        new THREE.MeshBasicMaterial({ color: b.color })
                    );
                    mesh.userData = { name: b.name };
                    scene.add(mesh);
                    celestialObjects.push(mesh);
                    
                    // Simple text sprite
                    const cvs = document.createElement('canvas');
                    const ctx = cvs.getContext('2d');
                    cvs.width = 128; cvs.height = 64;
                    ctx.fillStyle='white'; ctx.font='24px Arial'; ctx.textAlign='center';
                    ctx.fillText(b.name, 64, 40);
                    const tex = new THREE.CanvasTexture(cvs);
                    const sprite = new THREE.Sprite(new THREE.SpriteMaterial({map:tex}));
                    sprite.scale.set(10,5,1);
                    sprite.position.y = b.size * 1.5;
                    mesh.add(sprite);
                }
                
                mesh.position.set(x, y, z);
                mesh.lookAt(camera.position);
                mesh.userData.az = hor.azimuth;
                mesh.userData.alt = hor.altitude;
            });
            log(`Updated ${bodies.length} celestial bodies.`);
        }

        // --- 4. User Interaction (The Tricky Part) ---

        startBtn.addEventListener('click', async () => {
            overlay.style.display = 'none';
            log("User clicked Start.");
            
            // 1. Get GPS
            log("Requesting GPS...");
            navigator.geolocation.getCurrentPosition(
                (pos) => {
                    userLoc.lat = pos.coords.latitude;
                    userLoc.lon = pos.coords.longitude;
                    log(`GPS Success: ${userLoc.lat.toFixed(2)}, ${userLoc.lon.toFixed(2)}`, '#00ff00');
                    updateObjects();
                },
                (err) => {
                    log("GPS Failed/Denied. Using Null Island (0,0).", 'orange');
                    userLoc = { lat: 0, lon: 0 };
                    updateObjects();
                }
            );

            // 2. Request Sensors
            if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
                log("iOS detected. Requesting Sensor Permission...");
                try {
                    const response = await DeviceOrientationEvent.requestPermission();
                    if (response === 'granted') {
                        log("Sensor Permission GRANTED.", '#00ff00');
                        activateSensors();
                    } else {
                        log("Sensor Permission DENIED.", 'red');
                    }
                } catch (error) {
                    log("Sensor Request Error: " + error.message, 'red');
                }
            } else {
                log("Non-iOS device. Attempting sensors directly...");
                activateSensors();
            }
        });

        function activateSensors() {
            try {
                sensorControls = new DeviceOrientationControls(camera);
                // Check if it actually sends data
                window.addEventListener('deviceorientation', (e) => {
                    if(!e.alpha && activeControlMode !== 'sensors') {
                        // Sometimes alpha is null on desktop or failed sensors
                        return;
                    }
                }, { once: true });
                
                activeControlMode = 'sensors';
                touchControls.enabled = false;
                log("Switched to Sensor Controls.", '#00ff00');
            } catch (e) {
                log("Sensor Init Failed: " + e.message, 'red');
            }
        }

        // --- 5. Main Loop ---

        function animate() {
            if(activeControlMode === 'sensors' && sensorControls) {
                sensorControls.update();
            } else {
                touchControls.update();
            }

            // Raycasting
            raycaster.setFromCamera(center, camera);
            const intersects = raycaster.intersectObjects(celestialObjects);
            if(intersects.length > 0) {
                const obj = intersects[0].object;
                uiName.innerText = obj.userData.name;
                uiCoords.innerText = `Az: ${Math.round(obj.userData.az)}° Alt: ${Math.round(obj.userData.alt)}°`;
            } else {
                uiName.innerText = "Sky View";
                uiCoords.innerText = activeControlMode === 'sensors' ? "Scanning..." : "Touch Drag Mode";
            }

            // Compass Update
            // Get camera Y rotation
            const vector = new THREE.Vector3();
            camera.getWorldDirection(vector);
            const theta = Math.atan2(vector.x, vector.z);
            let deg = Math.round(theta * (180 / Math.PI));
            // Adjust mapping
            deg = (deg + 360) % 360; 
            // Update strip position (approximate pixels)
            // 50px per tick (45 deg) -> 1.11 px per deg
            // This is a rough visualization
            const offset = deg * 1.5; 
            compassEl.style.transform = `translateX(-${offset}px)`;

            // Search Arrow
            const query = searchInput.value.toLowerCase();
            if(query.length > 2) {
                const found = celestialObjects.find(o => o.userData.name.toLowerCase().includes(query));
                if(found) {
                    arrowGuide.visible = true;
                    // Point arrow to object
                    const localPos = found.position.clone().applyMatrix4(camera.matrixWorldInverse);
                    arrowGuide.lookAt(localPos.x*10, localPos.y*10, localPos.z*10);
                } else {
                    arrowGuide.visible = false;
                }
            } else {
                arrowGuide.visible = false;
            }

            renderer.render(scene, camera);
        }

        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // Run Init
        init();

    </script>
</body>
</html>
