<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Pocket Planetarium</title>
    <style>
        :root {
            --primary: #4deeea;
            --glass: rgba(16, 20, 30, 0.75);
            --border: 1px solid rgba(255, 255, 255, 0.1);
        }

        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            color: white;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }

        /* UI Overlay */
        #ui-layer {
            position: absolute;
            z-index: 10;
            width: 100%;
            height: 100%;
            pointer-events: none; /* Let touches pass through to canvas */
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        /* Search Bar */
        .search-container {
            pointer-events: auto;
            margin: 20px;
            position: relative;
        }

        #search-input {
            width: 100%;
            padding: 15px 20px;
            border-radius: 30px;
            background: var(--glass);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: var(--border);
            color: white;
            font-size: 16px;
            outline: none;
            box-sizing: border-box;
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
            transition: 0.3s;
        }

        #search-input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 15px rgba(77, 238, 234, 0.3);
        }

        #results {
            position: absolute;
            top: 60px;
            left: 0;
            right: 0;
            background: var(--glass);
            backdrop-filter: blur(15px);
            border-radius: 15px;
            max-height: 50vh;
            overflow-y: auto;
            display: none;
            border: var(--border);
        }

        .result-item {
            padding: 15px;
            border-bottom: 1px solid rgba(255,255,255,0.05);
            cursor: pointer;
        }

        .result-item:last-child { border-bottom: none; }
        
        .result-item small {
            display: block;
            color: #aaa;
            font-size: 12px;
        }

        /* Footer Info */
        .hud-footer {
            padding: 20px;
            text-align: center;
            background: linear-gradient(to top, black, transparent);
            pointer-events: none;
        }

        #target-name {
            font-size: 24px;
            font-weight: 300;
            letter-spacing: 2px;
            text-shadow: 0 0 10px var(--primary);
            color: var(--primary);
        }

        /* Start Button / Splash */
        #splash-screen {
            position: absolute;
            z-index: 100;
            background: #050505;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            pointer-events: auto;
        }

        button.start-btn {
            background: transparent;
            color: var(--primary);
            border: 2px solid var(--primary);
            padding: 15px 40px;
            font-size: 18px;
            border-radius: 50px;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 2px;
            transition: 0.3s;
            margin-top: 20px;
        }

        button.start-btn:hover {
            background: var(--primary);
            color: black;
            box-shadow: 0 0 20px var(--primary);
        }
        
        /* Reticle */
        .reticle {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 20px;
            height: 20px;
            transform: translate(-50%, -50%);
            border: 1px solid rgba(255,255,255,0.3);
            border-radius: 50%;
            pointer-events: none;
        }
        .reticle::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 2px;
            height: 2px;
            background: red;
            transform: translate(-50%, -50%);
        }

    </style>
</head>
<body>

    <!-- Permission / Splash Screen -->
    <div id="splash-screen">
        <h1 style="font-weight: 200; margin-bottom: 0;">STARRY NIGHT<span style="color:var(--primary); font-weight: bold;">GAZER</span></h1>
        <p style="color: #666; font-size: 14px;">Explore the universe with your phone</p>
        <button class="start-btn" onclick="initApp()">Start</button>
        <p style="color: #444; font-size: 10px; margin-top: 30px;">Requires Gyroscope & Secure Context (HTTPS)</p>
    </div>

    <!-- UI Overlay -->
    <div id="ui-layer">
        <div class="search-container">
            <input type="text" id="search-input" placeholder="Search stars, planets..." autocomplete="off">
            <div id="results"></div>
        </div>
        
        <!-- Center Reticle -->
        <div class="reticle"></div>

        <div class="hud-footer">
            <div id="target-name">SCANNING...</div>
            <div style="font-size: 12px; color: #777; margin-top: 5px;" id="coords">RA: 00 | DEC: 00</div>
        </div>
    </div>

    <!-- 3D Canvas -->
    <div id="canvas-container"></div>

    <!-- Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>

    <script>
        // --- 1. CONFIGURATION & DATA ---
        
        // Simplified Celestial Data (RA in degrees 0-360, Dec in degrees -90 to +90)
        // In a real app, you would load a JSON file.
        const CELESTIAL_DATA = [
            { name: "Sun", type: "Star", ra: 0, dec: 0, color: 0xffff00, size: 5 }, // Dynamic position omitted for simplicity
            { name: "Sirius", type: "Star", ra: 101.28, dec: -16.71, color: 0xffffff, size: 2.5 },
            { name: "Canopus", type: "Star", ra: 95.98, dec: -52.69, color: 0xffffee, size: 2.2 },
            { name: "Arcturus", type: "Star", ra: 213.91, dec: 19.18, color: 0xffccaa, size: 2.1 },
            { name: "Vega", type: "Star", ra: 279.23, dec: 38.78, color: 0xaaccff, size: 2.1 },
            { name: "Rigel", type: "Star", ra: 78.63, dec: -8.2, color: 0xaaccff, size: 2 },
            { name: "Betelgeuse", type: "Star", ra: 88.79, dec: 7.4, color: 0xffaa88, size: 2.3 },
            { name: "Procyon", type: "Star", ra: 114.82, dec: 5.22, color: 0xffffee, size: 1.8 },
            { name: "Achernar", type: "Star", ra: 24.42, dec: -57.23, color: 0xaaccff, size: 1.8 },
            { name: "Antares", type: "Star", ra: 247.35, dec: -26.43, color: 0xff4422, size: 2 },
            { name: "Andromeda Galaxy", type: "Deep Sky", ra: 10.68, dec: 41.26, color: 0xccddff, size: 3 },
            { name: "Polaris", type: "Star", ra: 37.95, dec: 89.26, color: 0xffffee, size: 1.8 },
            { name: "Mars", type: "Planet", ra: 45.5, dec: 15.2, color: 0xff5500, size: 3.5 }, // Fake static pos
            { name: "Jupiter", type: "Planet", ra: 100.5, dec: 10.2, color: 0xffddaa, size: 4 }, // Fake static pos
        ];

        let scene, camera, renderer, starMesh, labelRenderer;
        let controlsEnabled = false;
        
        // --- 2. INITIALIZATION ---

        function initApp() {
            // Request permissions for iOS 13+
            if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
                DeviceOrientationEvent.requestPermission()
                    .then(response => {
                        if (response === 'granted') {
                            startScene();
                        } else {
                            alert('Permission denied. App requires sensor access.');
                        }
                    })
                    .catch(console.error);
            } else {
                // Non-iOS or older devices
                startScene();
            }
        }

        function startScene() {
            document.getElementById('splash-screen').style.display = 'none';
            controlsEnabled = true;
            
            // Setup Three.js
            scene = new THREE.Scene();
            // Fog for atmosphere effect
            scene.fog = new THREE.FogExp2(0x000000, 0.002);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // Create Star Field (Background)
            createBackgroundStars();

            // Create Specific Objects (Interactable)
            createCelestialObjects();

            // Add Grid (Optional)
            const gridHelper = new THREE.PolarGridHelper(200, 16, 8, 64, 0x333333, 0x111111);
            scene.add(gridHelper);

            // Initial Camera Position
            camera.position.z = 0.1;

            // Events
            window.addEventListener('resize', onWindowResize, false);
            window.addEventListener('deviceorientation', onDeviceOrientation, false);

            animate();
        }

        // --- 3. SCENE GENERATION ---

        function createBackgroundStars() {
            const geometry = new THREE.BufferGeometry();
            const vertices = [];
            
            for (let i = 0; i < 3000; i++) {
                // Random position on sphere surface
                const r = 400;
                const theta = 2 * Math.PI * Math.random();
                const phi = Math.acos(2 * Math.random() - 1);
                
                const x = r * Math.sin(phi) * Math.cos(theta);
                const y = r * Math.sin(phi) * Math.sin(theta);
                const z = r * Math.cos(phi);

                vertices.push(x, y, z);
            }

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            
            // Shader material for glowing points
            const material = new THREE.PointsMaterial({ 
                color: 0xffffff, 
                size: 2, 
                sizeAttenuation: true,
                transparent: true,
                opacity: 0.8 
            });

            const points = new THREE.Points(geometry, material);
            scene.add(points);
        }

        const objectMeshes = [];

        function createCelestialObjects() {
            // Pre-calculate positions from RA/Dec
            CELESTIAL_DATA.forEach(obj => {
                // Convert RA/Dec to Cartesian
                // RA: 0-360 deg, Dec: -90 to 90 deg
                // Three.js Coordinate system: Y is up.
                // Physics/Astro Convention: Z is up usually, but here we map:
                // Z axis = North Pole (approx)
                
                const phi = (90 - obj.dec) * (Math.PI / 180); 
                const theta = (obj.ra) * (Math.PI / 180);
                const r = 300; // Distance from camera

                // Standard Spherical to Cartesian
                // Swap Y and Z for Three.js specific orientation if needed, 
                // but let's stick to standard Y-up for now and adjust controls.
                const x = -r * Math.sin(phi) * Math.cos(theta); // Negate X to match sky view looking out
                const y = r * Math.cos(phi);
                const z = -r * Math.sin(phi) * Math.sin(theta);

                // Create Mesh
                const geometry = new THREE.SphereGeometry(obj.size, 16, 16);
                const material = new THREE.MeshBasicMaterial({ color: obj.color });
                const mesh = new THREE.Mesh(geometry, material);
                
                mesh.position.set(x, y, z);
                mesh.userData = obj; // Store data in mesh
                
                // Add Glow
                const glowGeo = new THREE.SphereGeometry(obj.size * 2, 16, 16);
                const glowMat = new THREE.MeshBasicMaterial({ 
                    color: obj.color, 
                    transparent: true, 
                    opacity: 0.15,
                    side: THREE.BackSide
                });
                const glow = new THREE.Mesh(glowGeo, glowMat);
                mesh.add(glow);

                scene.add(mesh);
                objectMeshes.push(mesh);
            });
        }

        // --- 4. CONTROLS (SENSOR LOGIC) ---
        
        let deviceEuler = new THREE.Euler();
        let deviceQuaternion = new THREE.Quaternion();
        const screenTransform = new THREE.Quaternion();
        
        // Adjust for screen orientation (Portrait/Landscape)
        screenTransform.setFromAxisAngle(new THREE.Vector3(0, 0, 1), 0); 

        function onDeviceOrientation(event) {
            if (!controlsEnabled) return;

            const alpha = event.alpha ? THREE.MathUtils.degToRad(event.alpha) : 0; // Z axis
            const beta = event.beta ? THREE.MathUtils.degToRad(event.beta) : 0;   // X axis
            const gamma = event.gamma ? THREE.MathUtils.degToRad(event.gamma) : 0; // Y axis

            const orient = window.orientation ? THREE.MathUtils.degToRad(window.orientation) : 0;

            // This math converts browser alpha/beta/gamma to Three.js camera quaternion
            // Source: Three.js DeviceOrientationControls logic simplified
            
            const zee = new THREE.Vector3(0, 0, 1);
            const euler = new THREE.Euler();
            const q0 = new THREE.Quaternion();
            const q1 = new THREE.Quaternion(-Math.sqrt(0.5), 0, 0, Math.sqrt(0.5)); // - PI/2 around X

            euler.set(beta, alpha, -gamma, 'YXZ');
            const quaternion = new THREE.Quaternion();
            quaternion.setFromEuler(euler);
            quaternion.multiply(q1);
            quaternion.multiply(q0.setFromAxisAngle(zee, -orient));

            camera.quaternion.copy(quaternion);

            updateHUD();
        }

        // --- 5. RAYCASTING & UI ---
        
        const raycaster = new THREE.Raycaster();
        const center = new THREE.Vector2(0, 0); // Center of screen

        function updateHUD() {
            // Raycast from center of camera
            raycaster.setFromCamera(center, camera);
            const intersects = raycaster.intersectObjects(objectMeshes);

            const hudName = document.getElementById('target-name');
            const hudCoords = document.getElementById('coords');

            // Calculate current RA/Dec camera is facing
            const dir = new THREE.Vector3();
            camera.getWorldDirection(dir);
            // Convert Vector to RA/Dec (Approximate inverse of generation)
            // Just for display visuals
            
            if (intersects.length > 0) {
                const target = intersects[0].object.userData;
                hudName.innerText = target.name.toUpperCase();
                hudName.style.color = '#' + target.color.toString(16);
            } else {
                hudName.innerText = "";
            }
        }

        // --- 6. SEARCH FUNCTIONALITY ---

        const searchInput = document.getElementById('search-input');
        const resultsDiv = document.getElementById('results');

        searchInput.addEventListener('input', (e) => {
            const query = e.target.value.toLowerCase();
            resultsDiv.innerHTML = '';
            
            if (query.length < 1) {
                resultsDiv.style.display = 'none';
                return;
            }

            const matches = CELESTIAL_DATA.filter(obj => obj.name.toLowerCase().includes(query));
            
            if (matches.length > 0) {
                resultsDiv.style.display = 'block';
                matches.forEach(obj => {
                    const div = document.createElement('div');
                    div.className = 'result-item';
                    div.innerHTML = `<strong>${obj.name}</strong><small>${obj.type}</small>`;
                    div.onclick = () => pointTo(obj);
                    resultsDiv.appendChild(div);
                });
            } else {
                resultsDiv.style.display = 'none';
            }
        });

        function pointTo(objData) {
            // This is complex with Device Orientation active.
            // Instead of forcing the camera (which fights the sensor),
            // We will create a visual guide (arrow) or just highlight it.
            // For this demo, let's look at it, but if sensors are active, it will snap back.
            // So we disable sensors temporarily or provide a visual "Look Here" cue.
            
            // To keep it simple: We just log the location and highlight.
            // In a pro app, you'd draw a 3D arrow.
            
            alert(`Look for ${objData.name} at RA: ${objData.ra}, Dec: ${objData.dec}. (Follow the glow!)`);
            
            // Close search
            resultsDiv.style.display = 'none';
            searchInput.value = '';
        }

        // --- 7. CORE LOOP ---

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate(time) {
            requestAnimationFrame(animate);
            TWEEN.update(time);
            renderer.render(scene, camera);
        }

    </script>
</body>
</html>
